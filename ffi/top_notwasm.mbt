// Generated by `cmd/gen-ffi-top-notwasm` 0.41.0. DO NOT EDIT!

pub fn extend16(_value : Int) -> Int { abort("not wasm") }

pub fn extend8(_value : Int) -> Int { abort("not wasm") }

pub fn store8(_offset : Int, _value : Int) -> Unit { abort("not wasm") }

pub fn load8_u(_offset : Int) -> Int { abort("not wasm") }

pub fn load8(_offset : Int) -> Int { abort("not wasm") }

pub fn store16(_offset : Int, _value : Int) -> Unit { abort("not wasm") }

pub fn load16(_offset : Int) -> Int { abort("not wasm") }

pub fn load16_u(_offset : Int) -> Int { abort("not wasm") }

pub fn store32(_offset : Int, _value : Int) -> Unit { abort("not wasm") }

pub fn load32(_offset : Int) -> Int { abort("not wasm") }

pub fn store64(_offset : Int, _value : Int64) -> Unit { abort("not wasm") }

pub fn load64(_offset : Int) -> Int64 { abort("not wasm") }

pub fn storef32(_offset : Int, _value : Float) -> Unit { abort("not wasm") }

pub fn loadf32(_offset : Int) -> Float { abort("not wasm") }

pub fn storef64(_offset : Int, _value : Double) -> Unit { abort("not wasm") }

pub fn loadf64(_offset : Int) -> Double { abort("not wasm") }

pub fn f32_to_i32(_value : Float) -> Int { abort("not wasm") }

pub fn f32_to_i64(_value : Float) -> Int64 { abort("not wasm") }

// set pseudo header; allocate extra bytes for string
pub fn malloc(_size : Int) -> Int { abort("not wasm") }
#| local.get 0 i32.const 4 i32.add call $moonbit.gc.malloc
#| local.tee 1 i32.const 0 call $moonbit.init_array8
#| local.get 1 i32.const 8 i32.add)

pub fn free(_position : Int) -> Unit { abort("not wasm") }



pub fn str2ptr(_str : String) -> Int { abort("not wasm") }

pub fn ptr2str(_ptr : Int, _len : Int) -> String { abort("not wasm") }
#| local.get 0 i32.const 8 i32.sub local.tee 2
#| local.get 1 call $moonbit.init_array16
#| local.get 2)

pub fn bytes2ptr(_bytes : FixedArray[Byte]) -> Int { abort("not wasm") }

pub fn ptr2bytes(_ptr : Int, _len : Int) -> FixedArray[Byte] { abort("not wasm") }
#| local.get 0 i32.const 8 i32.sub local.tee 2
#| local.get 1 call $moonbit.init_array8
#| local.get 2)

pub fn uint_array2ptr(_array : FixedArray[UInt]) -> Int { abort("not wasm") }

pub fn uint64_array2ptr(_array : FixedArray[UInt64]) -> Int { abort("not wasm") }

pub fn int_array2ptr(_array : FixedArray[Int]) -> Int { abort("not wasm") }

pub fn int64_array2ptr(_array : FixedArray[Int64]) -> Int { abort("not wasm") }

pub fn float_array2ptr(_array : FixedArray[Float]) -> Int { abort("not wasm") }

pub fn double_array2ptr(_array : FixedArray[Double]) -> Int { abort("not wasm") }

pub fn ptr2uint_array(_ptr : Int, _len : Int) -> FixedArray[UInt] { abort("not wasm") }
#| local.get 0 i32.const 8 i32.sub local.tee 2
#| local.get 1 call $moonbit.init_array32
#| local.get 2)

pub fn ptr2int_array(_ptr : Int, _len : Int) -> FixedArray[Int] { abort("not wasm") }
#| local.get 0 i32.const 8 i32.sub local.tee 2
#| local.get 1 call $moonbit.init_array32
#| local.get 2)

pub fn ptr2float_array(_ptr : Int, _len : Int) -> FixedArray[Float] { abort("not wasm") }
#| local.get 0 i32.const 8 i32.sub local.tee 2
#| local.get 1 call $moonbit.init_array32
#| local.get 2)

pub fn ptr2uint64_array(_ptr : Int, _len : Int) -> FixedArray[UInt64] { abort("not wasm") }
#| local.get 0 i32.const 8 i32.sub local.tee 2
#| local.get 1 call $moonbit.init_array64
#| local.get 2)

pub fn ptr2int64_array(_ptr : Int, _len : Int) -> FixedArray[Int64] { abort("not wasm") }
#| local.get 0 i32.const 8 i32.sub local.tee 2
#| local.get 1 call $moonbit.init_array64
#| local.get 2)

pub fn ptr2double_array(_ptr : Int, _len : Int) -> FixedArray[Double] { abort("not wasm") }
#| local.get 0 i32.const 8 i32.sub local.tee 2
#| local.get 1 call $moonbit.init_array64
#| local.get 2)

pub fn cabi_realloc(
_src_offset : Int,
_src_size : Int,
__dst_alignment : Int,
_dst_size : Int
) -> Int { abort("not wasm") }

pub(open) trait Any {}
pub(all) struct Cleanup {
      address : Int
      size : Int
      align : Int
}
