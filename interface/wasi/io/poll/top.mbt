// Generated by `wit-bindgen` 0.41.0. DO NOT EDIT!
///| `pollable` represents a single I/O event which may be ready, or not.
pub(all) type Pollable Int derive(Show, Eq)

///| Drops a resource handle.
pub fn Pollable::drop(self : Pollable) -> Unit {
  let Pollable(resource) = self
  wasmImportResourceDropPollable(resource)
}

///| Return the readiness of a pollable. This function never blocks.
///
/// Returns `true` when the pollable is ready, and `false` otherwise.
pub fn Pollable::ready(self : Pollable) -> Bool {
  let Pollable(handle) = self
  let result : Int = wasmImportMethodPollableReady(handle)
  return result != 0
}

///| `block` returns immediately if the pollable is ready, and otherwise
/// blocks until ready.
///
/// This function is equivalent to calling `poll.poll` on a list
/// containing only this pollable.
pub fn Pollable::block(self : Pollable) -> Unit {
  let Pollable(handle) = self
  wasmImportMethodPollableBlock(handle)
}

///| Poll for completion on a set of pollables.
///
/// This function takes a list of pollables, which identify I/O sources of
/// interest, and waits until one or more of the events is ready for I/O.
///
/// The result `list<u32>` contains one or more indices of handles in the
/// argument list that is ready for I/O.
///
/// If the list contains more elements than can be indexed with a `u32`
/// value, this function traps.
///
/// A timeout can be implemented by adding a pollable from the
/// wasi-clocks API to the list.
///
/// This function does not return a `result`; polling in itself does not
/// do any I/O so it doesn't fail. If any of the I/O sources identified by
/// the pollables has an error, it is indicated by marking the source as
/// being reaedy for I/O.
pub fn poll(in_ : Array[Pollable]) -> FixedArray[UInt] {
  let address = @ffi.malloc(in_.length() * 4)
  for index = 0; index < in_.length(); index = index + 1 {
    let element : Pollable = in_[index]
    let base = address + index * 4
    let Pollable(handle) = element
    @ffi.store32(base + 0, handle)
  }
  let return_area = @ffi.malloc(8)
  wasmImportPoll(address, in_.length(), return_area)
  let result = @ffi.ptr2uint_array(
    @ffi.load32(return_area + 0),
    @ffi.load32(return_area + 4),
  )
  @ffi.free(address)
  @ffi.free(return_area)
  return result
}
