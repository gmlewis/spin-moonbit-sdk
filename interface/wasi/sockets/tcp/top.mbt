// Generated by `wit-bindgen` 0.41.0. DO NOT EDIT!

///|
pub(all) enum ShutdownType {
  RECEIVE
  SEND
  BOTH
} derive(Show, Eq)

///|
pub fn ShutdownType::ordinal(self : ShutdownType) -> Int {
  match self {
    RECEIVE => 0
    SEND => 1
    BOTH => 2
  }
}

///|
pub fn ShutdownType::from(self : Int) -> ShutdownType {
  match self {
    0 => RECEIVE
    1 => SEND
    2 => BOTH
    _ => panic()
  }
}

///| A TCP socket resource.
///
/// The socket can be in one of the following states:
/// - `unbound`
/// - `bind-in-progress`
/// - `bound` (See note below)
/// - `listen-in-progress`
/// - `listening`
/// - `connect-in-progress`
/// - `connected`
/// - `closed`
/// See <https://github.com/WebAssembly/wasi-sockets/TcpSocketOperationalSemantics.md>
/// for a more information.
///
/// Note: Except where explicitly mentioned, whenever this documentation uses
/// the term "bound" without backticks it actually means: in the `bound` state *or higher*.
/// (i.e. `bound`, `listen-in-progress`, `listening`, `connect-in-progress` or `connected`)
///
/// In addition to the general error codes documented on the
/// `network::error-code` type, TCP socket methods may always return
/// `error(invalid-state)` when in the `closed` state.
pub(all) type TcpSocket Int derive(Show, Eq)

///| Drops a resource handle.
pub fn TcpSocket::drop(self : TcpSocket) -> Unit {
  let TcpSocket(resource) = self
  wasmImportResourceDropTcpSocket(resource)
}

///| Bind the socket to a specific network on the provided IP address and port.
///
/// If the IP address is zero (`0.0.0.0` in IPv4, `::` in IPv6), it is left to the implementation to decide which
/// network interface(s) to bind to.
/// If the TCP/UDP port is zero, the socket will be bound to a random free port.
///
/// Bind can be attempted multiple times on the same socket, even with
/// different arguments on each iteration. But never concurrently and
/// only as long as the previous bind failed. Once a bind succeeds, the
/// binding can't be changed anymore.
///
/// # Typical errors
/// - `invalid-argument`:          The `local-address` has the wrong address family. (EAFNOSUPPORT, EFAULT on Windows)
/// - `invalid-argument`:          `local-address` is not a unicast address. (EINVAL)
/// - `invalid-argument`:          `local-address` is an IPv4-mapped IPv6 address. (EINVAL)
/// - `invalid-state`:             The socket is already bound. (EINVAL)
/// - `address-in-use`:            No ephemeral ports available. (EADDRINUSE, ENOBUFS on Windows)
/// - `address-in-use`:            Address is already in use. (EADDRINUSE)
/// - `address-not-bindable`:      `local-address` is not an address that the `network` can bind to. (EADDRNOTAVAIL)
/// - `not-in-progress`:           A `bind` operation is not in progress.
/// - `would-block`:               Can't finish the operation, it is still in progress. (EWOULDBLOCK, EAGAIN)
///
/// # Implementors note
/// When binding to a non-zero port, this bind operation shouldn't be affected by the TIME_WAIT
/// state of a recently closed socket on the same local address. In practice this means that the SO_REUSEADDR
/// socket option should be set implicitly on all platforms, except on Windows where this is the default behavior
/// and SO_REUSEADDR performs something different entirely.
///
/// Unlike in POSIX, in WASI the bind operation is async. This enables
/// interactive WASI hosts to inject permission prompts. Runtimes that
/// don't want to make use of this ability can simply call the native
/// `bind` as part of either `start-bind` or `finish-bind`.
///
/// # References
/// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/bind.html>
/// - <https://man7.org/linux/man-pages/man2/bind.2.html>
/// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-bind>
/// - <https://man.freebsd.org/cgi/man.cgi?query=bind&sektion=2&format=html>
pub fn TcpSocket::start_bind(
  self : TcpSocket,
  network : @network.Network,
  local_address : @network.IpSocketAddress
) -> Result[Unit, @network.ErrorCode] {
  let TcpSocket(handle) = self
  let @network.Network(handle0) = network
  let (
    lowered,
    lowered4,
    lowered5,
    lowered6,
    lowered7,
    lowered8,
    lowered9,
    lowered10,
    lowered11,
    lowered12,
    lowered13,
    lowered14,
  ) = match local_address {
    Ipv4(payload) =>
      (
        0,
        payload.port.reinterpret_as_int(),
        payload.address.0.to_int(),
        payload.address.1.to_int(),
        payload.address.2.to_int(),
        payload.address.3.to_int(),
        0,
        0,
        0,
        0,
        0,
        0,
      )
    Ipv6(payload3) =>
      (
        1,
        payload3.port.reinterpret_as_int(),
        payload3.flow_info.reinterpret_as_int(),
        payload3.address.0.reinterpret_as_int(),
        payload3.address.1.reinterpret_as_int(),
        payload3.address.2.reinterpret_as_int(),
        payload3.address.3.reinterpret_as_int(),
        payload3.address.4.reinterpret_as_int(),
        payload3.address.5.reinterpret_as_int(),
        payload3.address.6.reinterpret_as_int(),
        payload3.address.7.reinterpret_as_int(),
        payload3.scope_id.reinterpret_as_int(),
      )
  }
  let return_area = @ffi.malloc(2)
  wasmImportMethodTcpSocketStartBind(
    handle, handle0, lowered, lowered4, lowered5, lowered6, lowered7, lowered8, lowered9,
    lowered10, lowered11, lowered12, lowered13, lowered14, return_area,
  )
  let lifted = match @ffi.load8_u(return_area + 0) {
    0 => Result::Ok(())
    1 => Result::Err(@network.ErrorCode::from(@ffi.load8_u(return_area + 1)))
    _ => panic()
  }
  @ffi.free(return_area)
  return lifted
}

///|
pub fn TcpSocket::finish_bind(
  self : TcpSocket
) -> Result[Unit, @network.ErrorCode] {
  let TcpSocket(handle) = self
  let return_area = @ffi.malloc(2)
  wasmImportMethodTcpSocketFinishBind(handle, return_area)
  let lifted = match @ffi.load8_u(return_area + 0) {
    0 => Result::Ok(())
    1 => Result::Err(@network.ErrorCode::from(@ffi.load8_u(return_area + 1)))
    _ => panic()
  }
  @ffi.free(return_area)
  return lifted
}

///| Connect to a remote endpoint.
///
/// On success:
/// - the socket is transitioned into the `connection` state.
/// - a pair of streams is returned that can be used to read & write to the connection
///
/// After a failed connection attempt, the socket will be in the `closed`
/// state and the only valid action left is to `drop` the socket. A single
/// socket can not be used to connect more than once.
///
/// # Typical errors
/// - `invalid-argument`:          The `remote-address` has the wrong address family. (EAFNOSUPPORT)
/// - `invalid-argument`:          `remote-address` is not a unicast address. (EINVAL, ENETUNREACH on Linux, EAFNOSUPPORT on MacOS)
/// - `invalid-argument`:          `remote-address` is an IPv4-mapped IPv6 address. (EINVAL, EADDRNOTAVAIL on Illumos)
/// - `invalid-argument`:          The IP address in `remote-address` is set to INADDR_ANY (`0.0.0.0` / `::`). (EADDRNOTAVAIL on Windows)
/// - `invalid-argument`:          The port in `remote-address` is set to 0. (EADDRNOTAVAIL on Windows)
/// - `invalid-argument`:          The socket is already attached to a different network. The `network` passed to `connect` must be identical to the one passed to `bind`.
/// - `invalid-state`:             The socket is already in the `connected` state. (EISCONN)
/// - `invalid-state`:             The socket is already in the `listening` state. (EOPNOTSUPP, EINVAL on Windows)
/// - `timeout`:                   Connection timed out. (ETIMEDOUT)
/// - `connection-refused`:        The connection was forcefully rejected. (ECONNREFUSED)
/// - `connection-reset`:          The connection was reset. (ECONNRESET)
/// - `connection-aborted`:        The connection was aborted. (ECONNABORTED)
/// - `remote-unreachable`:        The remote address is not reachable. (EHOSTUNREACH, EHOSTDOWN, ENETUNREACH, ENETDOWN, ENONET)
/// - `address-in-use`:            Tried to perform an implicit bind, but there were no ephemeral ports available. (EADDRINUSE, EADDRNOTAVAIL on Linux, EAGAIN on BSD)
/// - `not-in-progress`:           A connect operation is not in progress.
/// - `would-block`:               Can't finish the operation, it is still in progress. (EWOULDBLOCK, EAGAIN)
///
/// # Implementors note
/// The POSIX equivalent of `start-connect` is the regular `connect` syscall.
/// Because all WASI sockets are non-blocking this is expected to return
/// EINPROGRESS, which should be translated to `ok()` in WASI.
///
/// The POSIX equivalent of `finish-connect` is a `poll` for event `POLLOUT`
/// with a timeout of 0 on the socket descriptor. Followed by a check for
/// the `SO_ERROR` socket option, in case the poll signaled readiness.
///
/// # References
/// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/connect.html>
/// - <https://man7.org/linux/man-pages/man2/connect.2.html>
/// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-connect>
/// - <https://man.freebsd.org/cgi/man.cgi?connect>
pub fn TcpSocket::start_connect(
  self : TcpSocket,
  network : @network.Network,
  remote_address : @network.IpSocketAddress
) -> Result[Unit, @network.ErrorCode] {
  let TcpSocket(handle) = self
  let @network.Network(handle0) = network
  let (
    lowered,
    lowered4,
    lowered5,
    lowered6,
    lowered7,
    lowered8,
    lowered9,
    lowered10,
    lowered11,
    lowered12,
    lowered13,
    lowered14,
  ) = match remote_address {
    Ipv4(payload) =>
      (
        0,
        payload.port.reinterpret_as_int(),
        payload.address.0.to_int(),
        payload.address.1.to_int(),
        payload.address.2.to_int(),
        payload.address.3.to_int(),
        0,
        0,
        0,
        0,
        0,
        0,
      )
    Ipv6(payload3) =>
      (
        1,
        payload3.port.reinterpret_as_int(),
        payload3.flow_info.reinterpret_as_int(),
        payload3.address.0.reinterpret_as_int(),
        payload3.address.1.reinterpret_as_int(),
        payload3.address.2.reinterpret_as_int(),
        payload3.address.3.reinterpret_as_int(),
        payload3.address.4.reinterpret_as_int(),
        payload3.address.5.reinterpret_as_int(),
        payload3.address.6.reinterpret_as_int(),
        payload3.address.7.reinterpret_as_int(),
        payload3.scope_id.reinterpret_as_int(),
      )
  }
  let return_area = @ffi.malloc(2)
  wasmImportMethodTcpSocketStartConnect(
    handle, handle0, lowered, lowered4, lowered5, lowered6, lowered7, lowered8, lowered9,
    lowered10, lowered11, lowered12, lowered13, lowered14, return_area,
  )
  let lifted = match @ffi.load8_u(return_area + 0) {
    0 => Result::Ok(())
    1 => Result::Err(@network.ErrorCode::from(@ffi.load8_u(return_area + 1)))
    _ => panic()
  }
  @ffi.free(return_area)
  return lifted
}

///|
pub fn TcpSocket::finish_connect(
  self : TcpSocket
) -> Result[(@streams.InputStream, @streams.OutputStream), @network.ErrorCode] {
  let TcpSocket(handle) = self
  let return_area = @ffi.malloc(12)
  wasmImportMethodTcpSocketFinishConnect(handle, return_area)
  let lifted = match @ffi.load8_u(return_area + 0) {
    0 =>
      Result::Ok(
        (
          @streams.InputStream::InputStream(@ffi.load32(return_area + 4)),
          @streams.OutputStream::OutputStream(@ffi.load32(return_area + 8)),
        ),
      )
    1 => Result::Err(@network.ErrorCode::from(@ffi.load8_u(return_area + 4)))
    _ => panic()
  }
  @ffi.free(return_area)
  return lifted
}

///| Start listening for new connections.
///
/// Transitions the socket into the `listening` state.
///
/// Unlike POSIX, the socket must already be explicitly bound.
///
/// # Typical errors
/// - `invalid-state`:             The socket is not bound to any local address. (EDESTADDRREQ)
/// - `invalid-state`:             The socket is already in the `connected` state. (EISCONN, EINVAL on BSD)
/// - `invalid-state`:             The socket is already in the `listening` state.
/// - `address-in-use`:            Tried to perform an implicit bind, but there were no ephemeral ports available. (EADDRINUSE)
/// - `not-in-progress`:           A listen operation is not in progress.
/// - `would-block`:               Can't finish the operation, it is still in progress. (EWOULDBLOCK, EAGAIN)
///
/// # Implementors note
/// Unlike in POSIX, in WASI the listen operation is async. This enables
/// interactive WASI hosts to inject permission prompts. Runtimes that
/// don't want to make use of this ability can simply call the native
/// `listen` as part of either `start-listen` or `finish-listen`.
///
/// # References
/// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/listen.html>
/// - <https://man7.org/linux/man-pages/man2/listen.2.html>
/// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-listen>
/// - <https://man.freebsd.org/cgi/man.cgi?query=listen&sektion=2>
pub fn TcpSocket::start_listen(
  self : TcpSocket
) -> Result[Unit, @network.ErrorCode] {
  let TcpSocket(handle) = self
  let return_area = @ffi.malloc(2)
  wasmImportMethodTcpSocketStartListen(handle, return_area)
  let lifted = match @ffi.load8_u(return_area + 0) {
    0 => Result::Ok(())
    1 => Result::Err(@network.ErrorCode::from(@ffi.load8_u(return_area + 1)))
    _ => panic()
  }
  @ffi.free(return_area)
  return lifted
}

///|
pub fn TcpSocket::finish_listen(
  self : TcpSocket
) -> Result[Unit, @network.ErrorCode] {
  let TcpSocket(handle) = self
  let return_area = @ffi.malloc(2)
  wasmImportMethodTcpSocketFinishListen(handle, return_area)
  let lifted = match @ffi.load8_u(return_area + 0) {
    0 => Result::Ok(())
    1 => Result::Err(@network.ErrorCode::from(@ffi.load8_u(return_area + 1)))
    _ => panic()
  }
  @ffi.free(return_area)
  return lifted
}

///| Accept a new client socket.
///
/// The returned socket is bound and in the `connected` state. The following properties are inherited from the listener socket:
/// - `address-family`
/// - `keep-alive-enabled`
/// - `keep-alive-idle-time`
/// - `keep-alive-interval`
/// - `keep-alive-count`
/// - `hop-limit`
/// - `receive-buffer-size`
/// - `send-buffer-size`
///
/// On success, this function returns the newly accepted client socket along with
/// a pair of streams that can be used to read & write to the connection.
///
/// # Typical errors
/// - `invalid-state`:      Socket is not in the `listening` state. (EINVAL)
/// - `would-block`:        No pending connections at the moment. (EWOULDBLOCK, EAGAIN)
/// - `connection-aborted`: An incoming connection was pending, but was terminated by the client before this listener could accept it. (ECONNABORTED)
/// - `new-socket-limit`:   The new socket resource could not be created because of a system limit. (EMFILE, ENFILE)
///
/// # References
/// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/accept.html>
/// - <https://man7.org/linux/man-pages/man2/accept.2.html>
/// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-accept>
/// - <https://man.freebsd.org/cgi/man.cgi?query=accept&sektion=2>
pub fn TcpSocket::accept(
  self : TcpSocket
) ->
     Result[
       (TcpSocket, @streams.InputStream, @streams.OutputStream),
       @network.ErrorCode,
     ] {
  let TcpSocket(handle) = self
  let return_area = @ffi.malloc(16)
  wasmImportMethodTcpSocketAccept(handle, return_area)
  let lifted = match @ffi.load8_u(return_area + 0) {
    0 =>
      Result::Ok(
        (
          TcpSocket::TcpSocket(@ffi.load32(return_area + 4)),
          @streams.InputStream::InputStream(@ffi.load32(return_area + 8)),
          @streams.OutputStream::OutputStream(@ffi.load32(return_area + 12)),
        ),
      )
    1 => Result::Err(@network.ErrorCode::from(@ffi.load8_u(return_area + 4)))
    _ => panic()
  }
  @ffi.free(return_area)
  return lifted
}

///| Get the bound local address.
///
/// POSIX mentions:
/// > If the socket has not been bound to a local name, the value
/// > stored in the object pointed to by `address` is unspecified.
///
/// WASI is stricter and requires `local-address` to return `invalid-state` when the socket hasn't been bound yet.
///
/// # Typical errors
/// - `invalid-state`: The socket is not bound to any local address.
///
/// # References
/// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/getsockname.html>
/// - <https://man7.org/linux/man-pages/man2/getsockname.2.html>
/// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-getsockname>
/// - <https://man.freebsd.org/cgi/man.cgi?getsockname>
pub fn TcpSocket::local_address(
  self : TcpSocket
) -> Result[@network.IpSocketAddress, @network.ErrorCode] {
  let TcpSocket(handle) = self
  let return_area = @ffi.malloc(36)
  wasmImportMethodTcpSocketLocalAddress(handle, return_area)
  let lifted6 = match @ffi.load8_u(return_area + 0) {
    0 => {
      let lifted = match @ffi.load8_u(return_area + 4) {
        0 =>
          @network.IpSocketAddress::Ipv4(@network.Ipv4SocketAddress::{
            port: @ffi.load16_u(return_area + 8)
            .land(0xFFFF)
            .reinterpret_as_uint(),
            address: (
              @ffi.load8_u(return_area + 10).to_byte(),
              @ffi.load8_u(return_area + 11).to_byte(),
              @ffi.load8_u(return_area + 12).to_byte(),
              @ffi.load8_u(return_area + 13).to_byte(),
            ),
          })
        1 =>
          @network.IpSocketAddress::Ipv6(@network.Ipv6SocketAddress::{
            port: @ffi.load16_u(return_area + 8)
            .land(0xFFFF)
            .reinterpret_as_uint(),
            flow_info: @ffi.load32(return_area + 12).reinterpret_as_uint(),
            address: (
              @ffi.load16_u(return_area + 16).land(0xFFFF).reinterpret_as_uint(),
              @ffi.load16_u(return_area + 18).land(0xFFFF).reinterpret_as_uint(),
              @ffi.load16_u(return_area + 20).land(0xFFFF).reinterpret_as_uint(),
              @ffi.load16_u(return_area + 22).land(0xFFFF).reinterpret_as_uint(),
              @ffi.load16_u(return_area + 24).land(0xFFFF).reinterpret_as_uint(),
              @ffi.load16_u(return_area + 26).land(0xFFFF).reinterpret_as_uint(),
              @ffi.load16_u(return_area + 28).land(0xFFFF).reinterpret_as_uint(),
              @ffi.load16_u(return_area + 30).land(0xFFFF).reinterpret_as_uint(),
            ),
            scope_id: @ffi.load32(return_area + 32).reinterpret_as_uint(),
          })
        _ => panic()
      }
      Result::Ok(lifted)
    }
    1 => Result::Err(@network.ErrorCode::from(@ffi.load8_u(return_area + 4)))
    _ => panic()
  }
  @ffi.free(return_area)
  return lifted6
}

///| Get the remote address.
///
/// # Typical errors
/// - `invalid-state`: The socket is not connected to a remote address. (ENOTCONN)
///
/// # References
/// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/getpeername.html>
/// - <https://man7.org/linux/man-pages/man2/getpeername.2.html>
/// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-getpeername>
/// - <https://man.freebsd.org/cgi/man.cgi?query=getpeername&sektion=2&n=1>
pub fn TcpSocket::remote_address(
  self : TcpSocket
) -> Result[@network.IpSocketAddress, @network.ErrorCode] {
  let TcpSocket(handle) = self
  let return_area = @ffi.malloc(36)
  wasmImportMethodTcpSocketRemoteAddress(handle, return_area)
  let lifted6 = match @ffi.load8_u(return_area + 0) {
    0 => {
      let lifted = match @ffi.load8_u(return_area + 4) {
        0 =>
          @network.IpSocketAddress::Ipv4(@network.Ipv4SocketAddress::{
            port: @ffi.load16_u(return_area + 8)
            .land(0xFFFF)
            .reinterpret_as_uint(),
            address: (
              @ffi.load8_u(return_area + 10).to_byte(),
              @ffi.load8_u(return_area + 11).to_byte(),
              @ffi.load8_u(return_area + 12).to_byte(),
              @ffi.load8_u(return_area + 13).to_byte(),
            ),
          })
        1 =>
          @network.IpSocketAddress::Ipv6(@network.Ipv6SocketAddress::{
            port: @ffi.load16_u(return_area + 8)
            .land(0xFFFF)
            .reinterpret_as_uint(),
            flow_info: @ffi.load32(return_area + 12).reinterpret_as_uint(),
            address: (
              @ffi.load16_u(return_area + 16).land(0xFFFF).reinterpret_as_uint(),
              @ffi.load16_u(return_area + 18).land(0xFFFF).reinterpret_as_uint(),
              @ffi.load16_u(return_area + 20).land(0xFFFF).reinterpret_as_uint(),
              @ffi.load16_u(return_area + 22).land(0xFFFF).reinterpret_as_uint(),
              @ffi.load16_u(return_area + 24).land(0xFFFF).reinterpret_as_uint(),
              @ffi.load16_u(return_area + 26).land(0xFFFF).reinterpret_as_uint(),
              @ffi.load16_u(return_area + 28).land(0xFFFF).reinterpret_as_uint(),
              @ffi.load16_u(return_area + 30).land(0xFFFF).reinterpret_as_uint(),
            ),
            scope_id: @ffi.load32(return_area + 32).reinterpret_as_uint(),
          })
        _ => panic()
      }
      Result::Ok(lifted)
    }
    1 => Result::Err(@network.ErrorCode::from(@ffi.load8_u(return_area + 4)))
    _ => panic()
  }
  @ffi.free(return_area)
  return lifted6
}

///| Whether the socket is in the `listening` state.
///
/// Equivalent to the SO_ACCEPTCONN socket option.
pub fn TcpSocket::is_listening(self : TcpSocket) -> Bool {
  let TcpSocket(handle) = self
  let result : Int = wasmImportMethodTcpSocketIsListening(handle)
  return result != 0
}

///| Whether this is a IPv4 or IPv6 socket.
///
/// Equivalent to the SO_DOMAIN socket option.
pub fn TcpSocket::address_family(self : TcpSocket) -> @network.IpAddressFamily {
  let TcpSocket(handle) = self
  let result : Int = wasmImportMethodTcpSocketAddressFamily(handle)
  return @network.IpAddressFamily::from(result)
}

///| Hints the desired listen queue size. Implementations are free to ignore this.
///
/// If the provided value is 0, an `invalid-argument` error is returned.
/// Any other value will never cause an error, but it might be silently clamped and/or rounded.
///
/// # Typical errors
/// - `not-supported`:        (set) The platform does not support changing the backlog size after the initial listen.
/// - `invalid-argument`:     (set) The provided value was 0.
/// - `invalid-state`:        (set) The socket is in the `connect-in-progress` or `connected` state.
pub fn TcpSocket::set_listen_backlog_size(
  self : TcpSocket,
  value : UInt64
) -> Result[Unit, @network.ErrorCode] {
  let TcpSocket(handle) = self
  let return_area = @ffi.malloc(2)
  wasmImportMethodTcpSocketSetListenBacklogSize(
    handle,
    value.reinterpret_as_int64(),
    return_area,
  )
  let lifted = match @ffi.load8_u(return_area + 0) {
    0 => Result::Ok(())
    1 => Result::Err(@network.ErrorCode::from(@ffi.load8_u(return_area + 1)))
    _ => panic()
  }
  @ffi.free(return_area)
  return lifted
}

///| Enables or disables keepalive.
///
/// The keepalive behavior can be adjusted using:
/// - `keep-alive-idle-time`
/// - `keep-alive-interval`
/// - `keep-alive-count`
/// These properties can be configured while `keep-alive-enabled` is false, but only come into effect when `keep-alive-enabled` is true.
///
/// Equivalent to the SO_KEEPALIVE socket option.
pub fn TcpSocket::keep_alive_enabled(
  self : TcpSocket
) -> Result[Bool, @network.ErrorCode] {
  let TcpSocket(handle) = self
  let return_area = @ffi.malloc(2)
  wasmImportMethodTcpSocketKeepAliveEnabled(handle, return_area)
  let lifted = match @ffi.load8_u(return_area + 0) {
    0 => Result::Ok(@ffi.load8_u(return_area + 1) != 0)
    1 => Result::Err(@network.ErrorCode::from(@ffi.load8_u(return_area + 1)))
    _ => panic()
  }
  @ffi.free(return_area)
  return lifted
}

///|
pub fn TcpSocket::set_keep_alive_enabled(
  self : TcpSocket,
  value : Bool
) -> Result[Unit, @network.ErrorCode] {
  let TcpSocket(handle) = self
  let return_area = @ffi.malloc(2)
  wasmImportMethodTcpSocketSetKeepAliveEnabled(
    handle,
    if value {
      1
    } else {
      0
    },
    return_area,
  )
  let lifted = match @ffi.load8_u(return_area + 0) {
    0 => Result::Ok(())
    1 => Result::Err(@network.ErrorCode::from(@ffi.load8_u(return_area + 1)))
    _ => panic()
  }
  @ffi.free(return_area)
  return lifted
}

///| Amount of time the connection has to be idle before TCP starts sending keepalive packets.
///
/// If the provided value is 0, an `invalid-argument` error is returned.
/// Any other value will never cause an error, but it might be silently clamped and/or rounded.
/// I.e. after setting a value, reading the same setting back may return a different value.
///
/// Equivalent to the TCP_KEEPIDLE socket option. (TCP_KEEPALIVE on MacOS)
///
/// # Typical errors
/// - `invalid-argument`:     (set) The provided value was 0.
pub fn TcpSocket::keep_alive_idle_time(
  self : TcpSocket
) -> Result[UInt64, @network.ErrorCode] {
  let TcpSocket(handle) = self
  let return_area = @ffi.malloc(16)
  wasmImportMethodTcpSocketKeepAliveIdleTime(handle, return_area)
  let lifted = match @ffi.load8_u(return_area + 0) {
    0 => Result::Ok(@ffi.load64(return_area + 8).reinterpret_as_uint64())
    1 => Result::Err(@network.ErrorCode::from(@ffi.load8_u(return_area + 8)))
    _ => panic()
  }
  @ffi.free(return_area)
  return lifted
}

///|
pub fn TcpSocket::set_keep_alive_idle_time(
  self : TcpSocket,
  value : UInt64
) -> Result[Unit, @network.ErrorCode] {
  let TcpSocket(handle) = self
  let return_area = @ffi.malloc(2)
  wasmImportMethodTcpSocketSetKeepAliveIdleTime(
    handle,
    value.reinterpret_as_int64(),
    return_area,
  )
  let lifted = match @ffi.load8_u(return_area + 0) {
    0 => Result::Ok(())
    1 => Result::Err(@network.ErrorCode::from(@ffi.load8_u(return_area + 1)))
    _ => panic()
  }
  @ffi.free(return_area)
  return lifted
}

///| The time between keepalive packets.
///
/// If the provided value is 0, an `invalid-argument` error is returned.
/// Any other value will never cause an error, but it might be silently clamped and/or rounded.
/// I.e. after setting a value, reading the same setting back may return a different value.
///
/// Equivalent to the TCP_KEEPINTVL socket option.
///
/// # Typical errors
/// - `invalid-argument`:     (set) The provided value was 0.
pub fn TcpSocket::keep_alive_interval(
  self : TcpSocket
) -> Result[UInt64, @network.ErrorCode] {
  let TcpSocket(handle) = self
  let return_area = @ffi.malloc(16)
  wasmImportMethodTcpSocketKeepAliveInterval(handle, return_area)
  let lifted = match @ffi.load8_u(return_area + 0) {
    0 => Result::Ok(@ffi.load64(return_area + 8).reinterpret_as_uint64())
    1 => Result::Err(@network.ErrorCode::from(@ffi.load8_u(return_area + 8)))
    _ => panic()
  }
  @ffi.free(return_area)
  return lifted
}

///|
pub fn TcpSocket::set_keep_alive_interval(
  self : TcpSocket,
  value : UInt64
) -> Result[Unit, @network.ErrorCode] {
  let TcpSocket(handle) = self
  let return_area = @ffi.malloc(2)
  wasmImportMethodTcpSocketSetKeepAliveInterval(
    handle,
    value.reinterpret_as_int64(),
    return_area,
  )
  let lifted = match @ffi.load8_u(return_area + 0) {
    0 => Result::Ok(())
    1 => Result::Err(@network.ErrorCode::from(@ffi.load8_u(return_area + 1)))
    _ => panic()
  }
  @ffi.free(return_area)
  return lifted
}

///| The maximum amount of keepalive packets TCP should send before aborting the connection.
///
/// If the provided value is 0, an `invalid-argument` error is returned.
/// Any other value will never cause an error, but it might be silently clamped and/or rounded.
/// I.e. after setting a value, reading the same setting back may return a different value.
///
/// Equivalent to the TCP_KEEPCNT socket option.
///
/// # Typical errors
/// - `invalid-argument`:     (set) The provided value was 0.
pub fn TcpSocket::keep_alive_count(
  self : TcpSocket
) -> Result[UInt, @network.ErrorCode] {
  let TcpSocket(handle) = self
  let return_area = @ffi.malloc(8)
  wasmImportMethodTcpSocketKeepAliveCount(handle, return_area)
  let lifted = match @ffi.load8_u(return_area + 0) {
    0 => Result::Ok(@ffi.load32(return_area + 4).reinterpret_as_uint())
    1 => Result::Err(@network.ErrorCode::from(@ffi.load8_u(return_area + 4)))
    _ => panic()
  }
  @ffi.free(return_area)
  return lifted
}

///|
pub fn TcpSocket::set_keep_alive_count(
  self : TcpSocket,
  value : UInt
) -> Result[Unit, @network.ErrorCode] {
  let TcpSocket(handle) = self
  let return_area = @ffi.malloc(2)
  wasmImportMethodTcpSocketSetKeepAliveCount(
    handle,
    value.reinterpret_as_int(),
    return_area,
  )
  let lifted = match @ffi.load8_u(return_area + 0) {
    0 => Result::Ok(())
    1 => Result::Err(@network.ErrorCode::from(@ffi.load8_u(return_area + 1)))
    _ => panic()
  }
  @ffi.free(return_area)
  return lifted
}

///| Equivalent to the IP_TTL & IPV6_UNICAST_HOPS socket options.
///
/// If the provided value is 0, an `invalid-argument` error is returned.
///
/// # Typical errors
/// - `invalid-argument`:     (set) The TTL value must be 1 or higher.
pub fn TcpSocket::hop_limit(
  self : TcpSocket
) -> Result[Byte, @network.ErrorCode] {
  let TcpSocket(handle) = self
  let return_area = @ffi.malloc(2)
  wasmImportMethodTcpSocketHopLimit(handle, return_area)
  let lifted = match @ffi.load8_u(return_area + 0) {
    0 => Result::Ok(@ffi.load8_u(return_area + 1).to_byte())
    1 => Result::Err(@network.ErrorCode::from(@ffi.load8_u(return_area + 1)))
    _ => panic()
  }
  @ffi.free(return_area)
  return lifted
}

///|
pub fn TcpSocket::set_hop_limit(
  self : TcpSocket,
  value : Byte
) -> Result[Unit, @network.ErrorCode] {
  let TcpSocket(handle) = self
  let return_area = @ffi.malloc(2)
  wasmImportMethodTcpSocketSetHopLimit(handle, value.to_int(), return_area)
  let lifted = match @ffi.load8_u(return_area + 0) {
    0 => Result::Ok(())
    1 => Result::Err(@network.ErrorCode::from(@ffi.load8_u(return_area + 1)))
    _ => panic()
  }
  @ffi.free(return_area)
  return lifted
}

///| The kernel buffer space reserved for sends/receives on this socket.
///
/// If the provided value is 0, an `invalid-argument` error is returned.
/// Any other value will never cause an error, but it might be silently clamped and/or rounded.
/// I.e. after setting a value, reading the same setting back may return a different value.
///
/// Equivalent to the SO_RCVBUF and SO_SNDBUF socket options.
///
/// # Typical errors
/// - `invalid-argument`:     (set) The provided value was 0.
pub fn TcpSocket::receive_buffer_size(
  self : TcpSocket
) -> Result[UInt64, @network.ErrorCode] {
  let TcpSocket(handle) = self
  let return_area = @ffi.malloc(16)
  wasmImportMethodTcpSocketReceiveBufferSize(handle, return_area)
  let lifted = match @ffi.load8_u(return_area + 0) {
    0 => Result::Ok(@ffi.load64(return_area + 8).reinterpret_as_uint64())
    1 => Result::Err(@network.ErrorCode::from(@ffi.load8_u(return_area + 8)))
    _ => panic()
  }
  @ffi.free(return_area)
  return lifted
}

///|
pub fn TcpSocket::set_receive_buffer_size(
  self : TcpSocket,
  value : UInt64
) -> Result[Unit, @network.ErrorCode] {
  let TcpSocket(handle) = self
  let return_area = @ffi.malloc(2)
  wasmImportMethodTcpSocketSetReceiveBufferSize(
    handle,
    value.reinterpret_as_int64(),
    return_area,
  )
  let lifted = match @ffi.load8_u(return_area + 0) {
    0 => Result::Ok(())
    1 => Result::Err(@network.ErrorCode::from(@ffi.load8_u(return_area + 1)))
    _ => panic()
  }
  @ffi.free(return_area)
  return lifted
}

///|
pub fn TcpSocket::send_buffer_size(
  self : TcpSocket
) -> Result[UInt64, @network.ErrorCode] {
  let TcpSocket(handle) = self
  let return_area = @ffi.malloc(16)
  wasmImportMethodTcpSocketSendBufferSize(handle, return_area)
  let lifted = match @ffi.load8_u(return_area + 0) {
    0 => Result::Ok(@ffi.load64(return_area + 8).reinterpret_as_uint64())
    1 => Result::Err(@network.ErrorCode::from(@ffi.load8_u(return_area + 8)))
    _ => panic()
  }
  @ffi.free(return_area)
  return lifted
}

///|
pub fn TcpSocket::set_send_buffer_size(
  self : TcpSocket,
  value : UInt64
) -> Result[Unit, @network.ErrorCode] {
  let TcpSocket(handle) = self
  let return_area = @ffi.malloc(2)
  wasmImportMethodTcpSocketSetSendBufferSize(
    handle,
    value.reinterpret_as_int64(),
    return_area,
  )
  let lifted = match @ffi.load8_u(return_area + 0) {
    0 => Result::Ok(())
    1 => Result::Err(@network.ErrorCode::from(@ffi.load8_u(return_area + 1)))
    _ => panic()
  }
  @ffi.free(return_area)
  return lifted
}

///| Create a `pollable` which can be used to poll for, or block on,
/// completion of any of the asynchronous operations of this socket.
///
/// When `finish-bind`, `finish-listen`, `finish-connect` or `accept`
/// return `error(would-block)`, this pollable can be used to wait for
/// their success or failure, after which the method can be retried.
///
/// The pollable is not limited to the async operation that happens to be
/// in progress at the time of calling `subscribe` (if any). Theoretically,
/// `subscribe` only has to be called once per socket and can then be
/// (re)used for the remainder of the socket's lifetime.
///
/// See <https://github.com/WebAssembly/wasi-sockets/TcpSocketOperationalSemantics.md#Pollable-readiness>
/// for a more information.
///
/// Note: this function is here for WASI Preview2 only.
/// It's planned to be removed when `future` is natively supported in Preview3.
pub fn TcpSocket::subscribe(self : TcpSocket) -> @poll.Pollable {
  let TcpSocket(handle) = self
  let result : Int = wasmImportMethodTcpSocketSubscribe(handle)
  return @poll.Pollable::Pollable(result)
}

///| Initiate a graceful shutdown.
///
/// - `receive`: The socket is not expecting to receive any data from
///   the peer. The `input-stream` associated with this socket will be
///   closed. Any data still in the receive queue at time of calling
///   this method will be discarded.
/// - `send`: The socket has no more data to send to the peer. The `output-stream`
///   associated with this socket will be closed and a FIN packet will be sent.
/// - `both`: Same effect as `receive` & `send` combined.
///
/// This function is idempotent. Shutting a down a direction more than once
/// has no effect and returns `ok`.
///
/// The shutdown function does not close (drop) the socket.
///
/// # Typical errors
/// - `invalid-state`: The socket is not in the `connected` state. (ENOTCONN)
///
/// # References
/// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/shutdown.html>
/// - <https://man7.org/linux/man-pages/man2/shutdown.2.html>
/// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-shutdown>
/// - <https://man.freebsd.org/cgi/man.cgi?query=shutdown&sektion=2>
pub fn TcpSocket::shutdown(
  self : TcpSocket,
  shutdown_type : ShutdownType
) -> Result[Unit, @network.ErrorCode] {
  let TcpSocket(handle) = self
  let return_area = @ffi.malloc(2)
  wasmImportMethodTcpSocketShutdown(
    handle,
    shutdown_type.ordinal(),
    return_area,
  )
  let lifted = match @ffi.load8_u(return_area + 0) {
    0 => Result::Ok(())
    1 => Result::Err(@network.ErrorCode::from(@ffi.load8_u(return_area + 1)))
    _ => panic()
  }
  @ffi.free(return_area)
  return lifted
}
