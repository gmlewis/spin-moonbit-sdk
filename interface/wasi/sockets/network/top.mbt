// Generated by `wit-bindgen` 0.41.0. DO NOT EDIT!

///| An opaque resource that represents access to (a subset of) the network.
/// This enables context-based security for networking.
/// There is no need for this to map 1:1 to a physical network interface.
pub(all) type Network Int derive(Show, Eq)

///| Drops a resource handle.
pub fn Network::drop(self : Network) -> Unit {
  let Network(resource) = self
  wasmImportResourceDropNetwork(resource)
}

///| Error codes.
///
/// In theory, every API can return any error code.
/// In practice, API's typically only return the errors documented per API
/// combined with a couple of errors that are always possible:
/// - `unknown`
/// - `access-denied`
/// - `not-supported`
/// - `out-of-memory`
/// - `concurrency-conflict`
///
/// See each individual API for what the POSIX equivalents are. They sometimes differ per API.
pub(all) enum ErrorCode {
  UNKNOWN
  ACCESS_DENIED
  NOT_SUPPORTED
  INVALID_ARGUMENT
  OUT_OF_MEMORY
  TIMEOUT
  CONCURRENCY_CONFLICT
  NOT_IN_PROGRESS
  WOULD_BLOCK
  INVALID_STATE
  NEW_SOCKET_LIMIT
  ADDRESS_NOT_BINDABLE
  ADDRESS_IN_USE
  REMOTE_UNREACHABLE
  CONNECTION_REFUSED
  CONNECTION_RESET
  CONNECTION_ABORTED
  DATAGRAM_TOO_LARGE
  NAME_UNRESOLVABLE
  TEMPORARY_RESOLVER_FAILURE
  PERMANENT_RESOLVER_FAILURE
} derive(Show, Eq)

///|
pub fn ErrorCode::ordinal(self : ErrorCode) -> Int {
  match self {
    UNKNOWN => 0
    ACCESS_DENIED => 1
    NOT_SUPPORTED => 2
    INVALID_ARGUMENT => 3
    OUT_OF_MEMORY => 4
    TIMEOUT => 5
    CONCURRENCY_CONFLICT => 6
    NOT_IN_PROGRESS => 7
    WOULD_BLOCK => 8
    INVALID_STATE => 9
    NEW_SOCKET_LIMIT => 10
    ADDRESS_NOT_BINDABLE => 11
    ADDRESS_IN_USE => 12
    REMOTE_UNREACHABLE => 13
    CONNECTION_REFUSED => 14
    CONNECTION_RESET => 15
    CONNECTION_ABORTED => 16
    DATAGRAM_TOO_LARGE => 17
    NAME_UNRESOLVABLE => 18
    TEMPORARY_RESOLVER_FAILURE => 19
    PERMANENT_RESOLVER_FAILURE => 20
  }
}

///|
pub fn ErrorCode::from(self : Int) -> ErrorCode {
  match self {
    0 => UNKNOWN
    1 => ACCESS_DENIED
    2 => NOT_SUPPORTED
    3 => INVALID_ARGUMENT
    4 => OUT_OF_MEMORY
    5 => TIMEOUT
    6 => CONCURRENCY_CONFLICT
    7 => NOT_IN_PROGRESS
    8 => WOULD_BLOCK
    9 => INVALID_STATE
    10 => NEW_SOCKET_LIMIT
    11 => ADDRESS_NOT_BINDABLE
    12 => ADDRESS_IN_USE
    13 => REMOTE_UNREACHABLE
    14 => CONNECTION_REFUSED
    15 => CONNECTION_RESET
    16 => CONNECTION_ABORTED
    17 => DATAGRAM_TOO_LARGE
    18 => NAME_UNRESOLVABLE
    19 => TEMPORARY_RESOLVER_FAILURE
    20 => PERMANENT_RESOLVER_FAILURE
    _ => panic()
  }
}

///|
pub(all) enum IpAddressFamily {
  IPV4
  IPV6
} derive(Show, Eq)

///|
pub fn IpAddressFamily::ordinal(self : IpAddressFamily) -> Int {
  match self {
    IPV4 => 0
    IPV6 => 1
  }
}

///|
pub fn IpAddressFamily::from(self : Int) -> IpAddressFamily {
  match self {
    0 => IPV4
    1 => IPV6
    _ => panic()
  }
}

///|
pub(all) enum IpAddress {
  Ipv4((Byte, Byte, Byte, Byte))
  Ipv6((UInt, UInt, UInt, UInt, UInt, UInt, UInt, UInt))
} derive(Show, Eq)

///|
pub(all) struct Ipv4SocketAddress {
  port : UInt
  address : (Byte, Byte, Byte, Byte)
} derive(Show, Eq)

///|
pub(all) struct Ipv6SocketAddress {
  port : UInt
  flow_info : UInt
  address : (UInt, UInt, UInt, UInt, UInt, UInt, UInt, UInt)
  scope_id : UInt
} derive(Show, Eq)

///|
pub(all) enum IpSocketAddress {
  Ipv4(Ipv4SocketAddress)
  Ipv6(Ipv6SocketAddress)
} derive(Show, Eq)
