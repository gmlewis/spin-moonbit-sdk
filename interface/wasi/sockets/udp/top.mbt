// Generated by `wit-bindgen` 0.41.0. DO NOT EDIT!
///| A received datagram.
pub(all) struct IncomingDatagram {
  data : FixedArray[Byte]
  remote_address : @network.IpSocketAddress
} derive(Show, Eq)

///| A datagram to be sent out.
pub(all) struct OutgoingDatagram {
  data : FixedArray[Byte]
  remote_address : @network.IpSocketAddress?
} derive(Show, Eq)

///| A UDP socket handle.
pub(all) type UdpSocket Int derive(Show, Eq)

///| Drops a resource handle.
pub fn UdpSocket::drop(self : UdpSocket) -> Unit {
  let UdpSocket(resource) = self
  wasmImportResourceDropUdpSocket(resource)
}

///|
pub(all) type IncomingDatagramStream Int derive(Show, Eq)

///| Drops a resource handle.
pub fn IncomingDatagramStream::drop(self : IncomingDatagramStream) -> Unit {
  let IncomingDatagramStream(resource) = self
  wasmImportResourceDropIncomingDatagramStream(resource)
}

///|
pub(all) type OutgoingDatagramStream Int derive(Show, Eq)

///| Drops a resource handle.
pub fn OutgoingDatagramStream::drop(self : OutgoingDatagramStream) -> Unit {
  let OutgoingDatagramStream(resource) = self
  wasmImportResourceDropOutgoingDatagramStream(resource)
}

///| Bind the socket to a specific network on the provided IP address and port.
///
/// If the IP address is zero (`0.0.0.0` in IPv4, `::` in IPv6), it is left to the implementation to decide which
/// network interface(s) to bind to.
/// If the port is zero, the socket will be bound to a random free port.
///
/// # Typical errors
/// - `invalid-argument`:          The `local-address` has the wrong address family. (EAFNOSUPPORT, EFAULT on Windows)
/// - `invalid-state`:             The socket is already bound. (EINVAL)
/// - `address-in-use`:            No ephemeral ports available. (EADDRINUSE, ENOBUFS on Windows)
/// - `address-in-use`:            Address is already in use. (EADDRINUSE)
/// - `address-not-bindable`:      `local-address` is not an address that the `network` can bind to. (EADDRNOTAVAIL)
/// - `not-in-progress`:           A `bind` operation is not in progress.
/// - `would-block`:               Can't finish the operation, it is still in progress. (EWOULDBLOCK, EAGAIN)
///
/// # Implementors note
/// Unlike in POSIX, in WASI the bind operation is async. This enables
/// interactive WASI hosts to inject permission prompts. Runtimes that
/// don't want to make use of this ability can simply call the native
/// `bind` as part of either `start-bind` or `finish-bind`.
///
/// # References
/// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/bind.html>
/// - <https://man7.org/linux/man-pages/man2/bind.2.html>
/// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-bind>
/// - <https://man.freebsd.org/cgi/man.cgi?query=bind&sektion=2&format=html>
pub fn UdpSocket::start_bind(
  self : UdpSocket,
  network : @network.Network,
  local_address : @network.IpSocketAddress
) -> Result[Unit, @network.ErrorCode] {
  let UdpSocket(handle) = self
  let @network.Network(handle0) = network
  let (
    lowered,
    lowered4,
    lowered5,
    lowered6,
    lowered7,
    lowered8,
    lowered9,
    lowered10,
    lowered11,
    lowered12,
    lowered13,
    lowered14,
  ) = match local_address {
    Ipv4(payload) =>
      (
        0,
        payload.port.reinterpret_as_int(),
        payload.address.0.to_int(),
        payload.address.1.to_int(),
        payload.address.2.to_int(),
        payload.address.3.to_int(),
        0,
        0,
        0,
        0,
        0,
        0,
      )
    Ipv6(payload3) =>
      (
        1,
        payload3.port.reinterpret_as_int(),
        payload3.flow_info.reinterpret_as_int(),
        payload3.address.0.reinterpret_as_int(),
        payload3.address.1.reinterpret_as_int(),
        payload3.address.2.reinterpret_as_int(),
        payload3.address.3.reinterpret_as_int(),
        payload3.address.4.reinterpret_as_int(),
        payload3.address.5.reinterpret_as_int(),
        payload3.address.6.reinterpret_as_int(),
        payload3.address.7.reinterpret_as_int(),
        payload3.scope_id.reinterpret_as_int(),
      )
  }
  let return_area = @ffi.malloc(2)
  wasmImportMethodUdpSocketStartBind(
    handle, handle0, lowered, lowered4, lowered5, lowered6, lowered7, lowered8, lowered9,
    lowered10, lowered11, lowered12, lowered13, lowered14, return_area,
  )
  let lifted = match @ffi.load8_u(return_area + 0) {
    0 => Result::Ok(())
    1 => Result::Err(@network.ErrorCode::from(@ffi.load8_u(return_area + 1)))
    _ => panic()
  }
  @ffi.free(return_area)
  return lifted
}

///|
pub fn UdpSocket::finish_bind(
  self : UdpSocket
) -> Result[Unit, @network.ErrorCode] {
  let UdpSocket(handle) = self
  let return_area = @ffi.malloc(2)
  wasmImportMethodUdpSocketFinishBind(handle, return_area)
  let lifted = match @ffi.load8_u(return_area + 0) {
    0 => Result::Ok(())
    1 => Result::Err(@network.ErrorCode::from(@ffi.load8_u(return_area + 1)))
    _ => panic()
  }
  @ffi.free(return_area)
  return lifted
}

///| Set up inbound & outbound communication channels, optionally to a specific peer.
///
/// This function only changes the local socket configuration and does not generate any network traffic.
/// On success, the `remote-address` of the socket is updated. The `local-address` may be updated as well,
/// based on the best network path to `remote-address`.
///
/// When a `remote-address` is provided, the returned streams are limited to communicating with that specific peer:
/// - `send` can only be used to send to this destination.
/// - `receive` will only return datagrams sent from the provided `remote-address`.
///
/// This method may be called multiple times on the same socket to change its association, but
/// only the most recently returned pair of streams will be operational. Implementations may trap if
/// the streams returned by a previous invocation haven't been dropped yet before calling `stream` again.
///
/// The POSIX equivalent in pseudo-code is:
/// ```text
/// if (was previously connected) {
/// 	connect(s, AF_UNSPEC)
/// }
/// if (remote_address is Some) {
/// 	connect(s, remote_address)
/// }
/// ```
///
/// Unlike in POSIX, the socket must already be explicitly bound.
///
/// # Typical errors
/// - `invalid-argument`:          The `remote-address` has the wrong address family. (EAFNOSUPPORT)
/// - `invalid-argument`:          The IP address in `remote-address` is set to INADDR_ANY (`0.0.0.0` / `::`). (EDESTADDRREQ, EADDRNOTAVAIL)
/// - `invalid-argument`:          The port in `remote-address` is set to 0. (EDESTADDRREQ, EADDRNOTAVAIL)
/// - `invalid-state`:             The socket is not bound.
/// - `address-in-use`:            Tried to perform an implicit bind, but there were no ephemeral ports available. (EADDRINUSE, EADDRNOTAVAIL on Linux, EAGAIN on BSD)
/// - `remote-unreachable`:        The remote address is not reachable. (ECONNRESET, ENETRESET, EHOSTUNREACH, EHOSTDOWN, ENETUNREACH, ENETDOWN, ENONET)
/// - `connection-refused`:        The connection was refused. (ECONNREFUSED)
///
/// # References
/// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/connect.html>
/// - <https://man7.org/linux/man-pages/man2/connect.2.html>
/// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-connect>
/// - <https://man.freebsd.org/cgi/man.cgi?connect>
pub fn UdpSocket::stream(
  self : UdpSocket,
  remote_address : @network.IpSocketAddress?
) ->
     Result[
       (IncomingDatagramStream, OutgoingDatagramStream),
       @network.ErrorCode,
     ] {
  let UdpSocket(handle) = self
  let (
    lowered20,
    lowered21,
    lowered22,
    lowered23,
    lowered24,
    lowered25,
    lowered26,
    lowered27,
    lowered28,
    lowered29,
    lowered30,
    lowered31,
    lowered32,
  ) = match remote_address {
    None => (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
    Some(payload2) => {
      let (
        lowered,
        lowered9,
        lowered10,
        lowered11,
        lowered12,
        lowered13,
        lowered14,
        lowered15,
        lowered16,
        lowered17,
        lowered18,
        lowered19,
      ) = match payload2 {
        Ipv4(payload5) =>
          (
            0,
            payload5.port.reinterpret_as_int(),
            payload5.address.0.to_int(),
            payload5.address.1.to_int(),
            payload5.address.2.to_int(),
            payload5.address.3.to_int(),
            0,
            0,
            0,
            0,
            0,
            0,
          )
        Ipv6(payload8) =>
          (
            1,
            payload8.port.reinterpret_as_int(),
            payload8.flow_info.reinterpret_as_int(),
            payload8.address.0.reinterpret_as_int(),
            payload8.address.1.reinterpret_as_int(),
            payload8.address.2.reinterpret_as_int(),
            payload8.address.3.reinterpret_as_int(),
            payload8.address.4.reinterpret_as_int(),
            payload8.address.5.reinterpret_as_int(),
            payload8.address.6.reinterpret_as_int(),
            payload8.address.7.reinterpret_as_int(),
            payload8.scope_id.reinterpret_as_int(),
          )
      }
      (
        1, lowered, lowered9, lowered10, lowered11, lowered12, lowered13, lowered14,
        lowered15, lowered16, lowered17, lowered18, lowered19,
      )
    }
  }
  let return_area = @ffi.malloc(12)
  wasmImportMethodUdpSocketStream(
    handle, lowered20, lowered21, lowered22, lowered23, lowered24, lowered25, lowered26,
    lowered27, lowered28, lowered29, lowered30, lowered31, lowered32, return_area,
  )
  let lifted = match @ffi.load8_u(return_area + 0) {
    0 =>
      Result::Ok(
        (
          IncomingDatagramStream::IncomingDatagramStream(
            @ffi.load32(return_area + 4),
          ),
          OutgoingDatagramStream::OutgoingDatagramStream(
            @ffi.load32(return_area + 8),
          ),
        ),
      )
    1 => Result::Err(@network.ErrorCode::from(@ffi.load8_u(return_area + 4)))
    _ => panic()
  }
  @ffi.free(return_area)
  return lifted
}

///| Get the current bound address.
///
/// POSIX mentions:
/// > If the socket has not been bound to a local name, the value
/// > stored in the object pointed to by `address` is unspecified.
///
/// WASI is stricter and requires `local-address` to return `invalid-state` when the socket hasn't been bound yet.
///
/// # Typical errors
/// - `invalid-state`: The socket is not bound to any local address.
///
/// # References
/// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/getsockname.html>
/// - <https://man7.org/linux/man-pages/man2/getsockname.2.html>
/// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-getsockname>
/// - <https://man.freebsd.org/cgi/man.cgi?getsockname>
pub fn UdpSocket::local_address(
  self : UdpSocket
) -> Result[@network.IpSocketAddress, @network.ErrorCode] {
  let UdpSocket(handle) = self
  let return_area = @ffi.malloc(36)
  wasmImportMethodUdpSocketLocalAddress(handle, return_area)
  let lifted6 = match @ffi.load8_u(return_area + 0) {
    0 => {
      let lifted = match @ffi.load8_u(return_area + 4) {
        0 =>
          @network.IpSocketAddress::Ipv4(@network.Ipv4SocketAddress::{
            port: @ffi.load16_u(return_area + 8)
            .land(0xFFFF)
            .reinterpret_as_uint(),
            address: (
              @ffi.load8_u(return_area + 10).to_byte(),
              @ffi.load8_u(return_area + 11).to_byte(),
              @ffi.load8_u(return_area + 12).to_byte(),
              @ffi.load8_u(return_area + 13).to_byte(),
            ),
          })
        1 =>
          @network.IpSocketAddress::Ipv6(@network.Ipv6SocketAddress::{
            port: @ffi.load16_u(return_area + 8)
            .land(0xFFFF)
            .reinterpret_as_uint(),
            flow_info: @ffi.load32(return_area + 12).reinterpret_as_uint(),
            address: (
              @ffi.load16_u(return_area + 16).land(0xFFFF).reinterpret_as_uint(),
              @ffi.load16_u(return_area + 18).land(0xFFFF).reinterpret_as_uint(),
              @ffi.load16_u(return_area + 20).land(0xFFFF).reinterpret_as_uint(),
              @ffi.load16_u(return_area + 22).land(0xFFFF).reinterpret_as_uint(),
              @ffi.load16_u(return_area + 24).land(0xFFFF).reinterpret_as_uint(),
              @ffi.load16_u(return_area + 26).land(0xFFFF).reinterpret_as_uint(),
              @ffi.load16_u(return_area + 28).land(0xFFFF).reinterpret_as_uint(),
              @ffi.load16_u(return_area + 30).land(0xFFFF).reinterpret_as_uint(),
            ),
            scope_id: @ffi.load32(return_area + 32).reinterpret_as_uint(),
          })
        _ => panic()
      }
      Result::Ok(lifted)
    }
    1 => Result::Err(@network.ErrorCode::from(@ffi.load8_u(return_area + 4)))
    _ => panic()
  }
  @ffi.free(return_area)
  return lifted6
}

///| Get the address the socket is currently streaming to.
///
/// # Typical errors
/// - `invalid-state`: The socket is not streaming to a specific remote address. (ENOTCONN)
///
/// # References
/// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/getpeername.html>
/// - <https://man7.org/linux/man-pages/man2/getpeername.2.html>
/// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-getpeername>
/// - <https://man.freebsd.org/cgi/man.cgi?query=getpeername&sektion=2&n=1>
pub fn UdpSocket::remote_address(
  self : UdpSocket
) -> Result[@network.IpSocketAddress, @network.ErrorCode] {
  let UdpSocket(handle) = self
  let return_area = @ffi.malloc(36)
  wasmImportMethodUdpSocketRemoteAddress(handle, return_area)
  let lifted6 = match @ffi.load8_u(return_area + 0) {
    0 => {
      let lifted = match @ffi.load8_u(return_area + 4) {
        0 =>
          @network.IpSocketAddress::Ipv4(@network.Ipv4SocketAddress::{
            port: @ffi.load16_u(return_area + 8)
            .land(0xFFFF)
            .reinterpret_as_uint(),
            address: (
              @ffi.load8_u(return_area + 10).to_byte(),
              @ffi.load8_u(return_area + 11).to_byte(),
              @ffi.load8_u(return_area + 12).to_byte(),
              @ffi.load8_u(return_area + 13).to_byte(),
            ),
          })
        1 =>
          @network.IpSocketAddress::Ipv6(@network.Ipv6SocketAddress::{
            port: @ffi.load16_u(return_area + 8)
            .land(0xFFFF)
            .reinterpret_as_uint(),
            flow_info: @ffi.load32(return_area + 12).reinterpret_as_uint(),
            address: (
              @ffi.load16_u(return_area + 16).land(0xFFFF).reinterpret_as_uint(),
              @ffi.load16_u(return_area + 18).land(0xFFFF).reinterpret_as_uint(),
              @ffi.load16_u(return_area + 20).land(0xFFFF).reinterpret_as_uint(),
              @ffi.load16_u(return_area + 22).land(0xFFFF).reinterpret_as_uint(),
              @ffi.load16_u(return_area + 24).land(0xFFFF).reinterpret_as_uint(),
              @ffi.load16_u(return_area + 26).land(0xFFFF).reinterpret_as_uint(),
              @ffi.load16_u(return_area + 28).land(0xFFFF).reinterpret_as_uint(),
              @ffi.load16_u(return_area + 30).land(0xFFFF).reinterpret_as_uint(),
            ),
            scope_id: @ffi.load32(return_area + 32).reinterpret_as_uint(),
          })
        _ => panic()
      }
      Result::Ok(lifted)
    }
    1 => Result::Err(@network.ErrorCode::from(@ffi.load8_u(return_area + 4)))
    _ => panic()
  }
  @ffi.free(return_area)
  return lifted6
}

///| Whether this is a IPv4 or IPv6 socket.
///
/// Equivalent to the SO_DOMAIN socket option.
pub fn UdpSocket::address_family(self : UdpSocket) -> @network.IpAddressFamily {
  let UdpSocket(handle) = self
  let result : Int = wasmImportMethodUdpSocketAddressFamily(handle)
  return @network.IpAddressFamily::from(result)
}

///| Equivalent to the IP_TTL & IPV6_UNICAST_HOPS socket options.
///
/// If the provided value is 0, an `invalid-argument` error is returned.
///
/// # Typical errors
/// - `invalid-argument`:     (set) The TTL value must be 1 or higher.
pub fn UdpSocket::unicast_hop_limit(
  self : UdpSocket
) -> Result[Byte, @network.ErrorCode] {
  let UdpSocket(handle) = self
  let return_area = @ffi.malloc(2)
  wasmImportMethodUdpSocketUnicastHopLimit(handle, return_area)
  let lifted = match @ffi.load8_u(return_area + 0) {
    0 => Result::Ok(@ffi.load8_u(return_area + 1).to_byte())
    1 => Result::Err(@network.ErrorCode::from(@ffi.load8_u(return_area + 1)))
    _ => panic()
  }
  @ffi.free(return_area)
  return lifted
}

///|
pub fn UdpSocket::set_unicast_hop_limit(
  self : UdpSocket,
  value : Byte
) -> Result[Unit, @network.ErrorCode] {
  let UdpSocket(handle) = self
  let return_area = @ffi.malloc(2)
  wasmImportMethodUdpSocketSetUnicastHopLimit(
    handle,
    value.to_int(),
    return_area,
  )
  let lifted = match @ffi.load8_u(return_area + 0) {
    0 => Result::Ok(())
    1 => Result::Err(@network.ErrorCode::from(@ffi.load8_u(return_area + 1)))
    _ => panic()
  }
  @ffi.free(return_area)
  return lifted
}

///| The kernel buffer space reserved for sends/receives on this socket.
///
/// If the provided value is 0, an `invalid-argument` error is returned.
/// Any other value will never cause an error, but it might be silently clamped and/or rounded.
/// I.e. after setting a value, reading the same setting back may return a different value.
///
/// Equivalent to the SO_RCVBUF and SO_SNDBUF socket options.
///
/// # Typical errors
/// - `invalid-argument`:     (set) The provided value was 0.
pub fn UdpSocket::receive_buffer_size(
  self : UdpSocket
) -> Result[UInt64, @network.ErrorCode] {
  let UdpSocket(handle) = self
  let return_area = @ffi.malloc(16)
  wasmImportMethodUdpSocketReceiveBufferSize(handle, return_area)
  let lifted = match @ffi.load8_u(return_area + 0) {
    0 => Result::Ok(@ffi.load64(return_area + 8).reinterpret_as_uint64())
    1 => Result::Err(@network.ErrorCode::from(@ffi.load8_u(return_area + 8)))
    _ => panic()
  }
  @ffi.free(return_area)
  return lifted
}

///|
pub fn UdpSocket::set_receive_buffer_size(
  self : UdpSocket,
  value : UInt64
) -> Result[Unit, @network.ErrorCode] {
  let UdpSocket(handle) = self
  let return_area = @ffi.malloc(2)
  wasmImportMethodUdpSocketSetReceiveBufferSize(
    handle,
    value.reinterpret_as_int64(),
    return_area,
  )
  let lifted = match @ffi.load8_u(return_area + 0) {
    0 => Result::Ok(())
    1 => Result::Err(@network.ErrorCode::from(@ffi.load8_u(return_area + 1)))
    _ => panic()
  }
  @ffi.free(return_area)
  return lifted
}

///|
pub fn UdpSocket::send_buffer_size(
  self : UdpSocket
) -> Result[UInt64, @network.ErrorCode] {
  let UdpSocket(handle) = self
  let return_area = @ffi.malloc(16)
  wasmImportMethodUdpSocketSendBufferSize(handle, return_area)
  let lifted = match @ffi.load8_u(return_area + 0) {
    0 => Result::Ok(@ffi.load64(return_area + 8).reinterpret_as_uint64())
    1 => Result::Err(@network.ErrorCode::from(@ffi.load8_u(return_area + 8)))
    _ => panic()
  }
  @ffi.free(return_area)
  return lifted
}

///|
pub fn UdpSocket::set_send_buffer_size(
  self : UdpSocket,
  value : UInt64
) -> Result[Unit, @network.ErrorCode] {
  let UdpSocket(handle) = self
  let return_area = @ffi.malloc(2)
  wasmImportMethodUdpSocketSetSendBufferSize(
    handle,
    value.reinterpret_as_int64(),
    return_area,
  )
  let lifted = match @ffi.load8_u(return_area + 0) {
    0 => Result::Ok(())
    1 => Result::Err(@network.ErrorCode::from(@ffi.load8_u(return_area + 1)))
    _ => panic()
  }
  @ffi.free(return_area)
  return lifted
}

///| Create a `pollable` which will resolve once the socket is ready for I/O.
///
/// Note: this function is here for WASI Preview2 only.
/// It's planned to be removed when `future` is natively supported in Preview3.
pub fn UdpSocket::subscribe(self : UdpSocket) -> @poll.Pollable {
  let UdpSocket(handle) = self
  let result : Int = wasmImportMethodUdpSocketSubscribe(handle)
  return @poll.Pollable::Pollable(result)
}

///| Receive messages on the socket.
///
/// This function attempts to receive up to `max-results` datagrams on the socket without blocking.
/// The returned list may contain fewer elements than requested, but never more.
///
/// This function returns successfully with an empty list when either:
/// - `max-results` is 0, or:
/// - `max-results` is greater than 0, but no results are immediately available.
/// This function never returns `error(would-block)`.
///
/// # Typical errors
/// - `remote-unreachable`: The remote address is not reachable. (ECONNRESET, ENETRESET on Windows, EHOSTUNREACH, EHOSTDOWN, ENETUNREACH, ENETDOWN, ENONET)
/// - `connection-refused`: The connection was refused. (ECONNREFUSED)
///
/// # References
/// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/recvfrom.html>
/// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/recvmsg.html>
/// - <https://man7.org/linux/man-pages/man2/recv.2.html>
/// - <https://man7.org/linux/man-pages/man2/recvmmsg.2.html>
/// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-recv>
/// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-recvfrom>
/// - <https://learn.microsoft.com/en-us/previous-versions/windows/desktop/legacy/ms741687(v=vs.85)>
/// - <https://man.freebsd.org/cgi/man.cgi?query=recv&sektion=2>
pub fn IncomingDatagramStream::receive(
  self : IncomingDatagramStream,
  max_results : UInt64
) -> Result[Array[IncomingDatagram], @network.ErrorCode] {
  let IncomingDatagramStream(handle) = self
  let return_area = @ffi.malloc(12)
  wasmImportMethodIncomingDatagramStreamReceive(
    handle,
    max_results.reinterpret_as_int64(),
    return_area,
  )
  let lifted8 = match @ffi.load8_u(return_area + 0) {
    0 => {
      let array : Array[IncomingDatagram] = []
      for index = 0; index < @ffi.load32(return_area + 8); index = index + 1 {
        let base1 = @ffi.load32(return_area + 4) + index * 40
        let result = @ffi.ptr2bytes(
          @ffi.load32(base1 + 0),
          @ffi.load32(base1 + 4),
        )
        let lifted = match @ffi.load8_u(base1 + 8) {
          0 =>
            @network.IpSocketAddress::Ipv4(@network.Ipv4SocketAddress::{
              port: @ffi.load16_u(base1 + 12).land(0xFFFF).reinterpret_as_uint(),
              address: (
                @ffi.load8_u(base1 + 14).to_byte(),
                @ffi.load8_u(base1 + 15).to_byte(),
                @ffi.load8_u(base1 + 16).to_byte(),
                @ffi.load8_u(base1 + 17).to_byte(),
              ),
            })
          1 =>
            @network.IpSocketAddress::Ipv6(@network.Ipv6SocketAddress::{
              port: @ffi.load16_u(base1 + 12).land(0xFFFF).reinterpret_as_uint(),
              flow_info: @ffi.load32(base1 + 16).reinterpret_as_uint(),
              address: (
                @ffi.load16_u(base1 + 20).land(0xFFFF).reinterpret_as_uint(),
                @ffi.load16_u(base1 + 22).land(0xFFFF).reinterpret_as_uint(),
                @ffi.load16_u(base1 + 24).land(0xFFFF).reinterpret_as_uint(),
                @ffi.load16_u(base1 + 26).land(0xFFFF).reinterpret_as_uint(),
                @ffi.load16_u(base1 + 28).land(0xFFFF).reinterpret_as_uint(),
                @ffi.load16_u(base1 + 30).land(0xFFFF).reinterpret_as_uint(),
                @ffi.load16_u(base1 + 32).land(0xFFFF).reinterpret_as_uint(),
                @ffi.load16_u(base1 + 34).land(0xFFFF).reinterpret_as_uint(),
              ),
              scope_id: @ffi.load32(base1 + 36).reinterpret_as_uint(),
            })
          _ => panic()
        }
        array.push(IncomingDatagram::{ data: result, remote_address: lifted })
      }
      @ffi.free(@ffi.load32(return_area + 4))
      Result::Ok(array)
    }
    1 => Result::Err(@network.ErrorCode::from(@ffi.load8_u(return_area + 4)))
    _ => panic()
  }
  @ffi.free(return_area)
  return lifted8
}

///| Create a `pollable` which will resolve once the stream is ready to receive again.
///
/// Note: this function is here for WASI Preview2 only.
/// It's planned to be removed when `future` is natively supported in Preview3.
pub fn IncomingDatagramStream::subscribe(
  self : IncomingDatagramStream
) -> @poll.Pollable {
  let IncomingDatagramStream(handle) = self
  let result : Int = wasmImportMethodIncomingDatagramStreamSubscribe(handle)
  return @poll.Pollable::Pollable(result)
}

///| Check readiness for sending. This function never blocks.
///
/// Returns the number of datagrams permitted for the next call to `send`,
/// or an error. Calling `send` with more datagrams than this function has
/// permitted will trap.
///
/// When this function returns ok(0), the `subscribe` pollable will
/// become ready when this function will report at least ok(1), or an
/// error.
///
/// Never returns `would-block`.
pub fn OutgoingDatagramStream::check_send(
  self : OutgoingDatagramStream
) -> Result[UInt64, @network.ErrorCode] {
  let OutgoingDatagramStream(handle) = self
  let return_area = @ffi.malloc(16)
  wasmImportMethodOutgoingDatagramStreamCheckSend(handle, return_area)
  let lifted = match @ffi.load8_u(return_area + 0) {
    0 => Result::Ok(@ffi.load64(return_area + 8).reinterpret_as_uint64())
    1 => Result::Err(@network.ErrorCode::from(@ffi.load8_u(return_area + 8)))
    _ => panic()
  }
  @ffi.free(return_area)
  return lifted
}

///| Send messages on the socket.
///
/// This function attempts to send all provided `datagrams` on the socket without blocking and
/// returns how many messages were actually sent (or queued for sending). This function never
/// returns `error(would-block)`. If none of the datagrams were able to be sent, `ok(0)` is returned.
///
/// This function semantically behaves the same as iterating the `datagrams` list and sequentially
/// sending each individual datagram until either the end of the list has been reached or the first error occurred.
/// If at least one datagram has been sent successfully, this function never returns an error.
///
/// If the input list is empty, the function returns `ok(0)`.
///
/// Each call to `send` must be permitted by a preceding `check-send`. Implementations must trap if
/// either `check-send` was not called or `datagrams` contains more items than `check-send` permitted.
///
/// # Typical errors
/// - `invalid-argument`:        The `remote-address` has the wrong address family. (EAFNOSUPPORT)
/// - `invalid-argument`:        The IP address in `remote-address` is set to INADDR_ANY (`0.0.0.0` / `::`). (EDESTADDRREQ, EADDRNOTAVAIL)
/// - `invalid-argument`:        The port in `remote-address` is set to 0. (EDESTADDRREQ, EADDRNOTAVAIL)
/// - `invalid-argument`:        The socket is in "connected" mode and `remote-address` is `some` value that does not match the address passed to `stream`. (EISCONN)
/// - `invalid-argument`:        The socket is not "connected" and no value for `remote-address` was provided. (EDESTADDRREQ)
/// - `remote-unreachable`:      The remote address is not reachable. (ECONNRESET, ENETRESET on Windows, EHOSTUNREACH, EHOSTDOWN, ENETUNREACH, ENETDOWN, ENONET)
/// - `connection-refused`:      The connection was refused. (ECONNREFUSED)
/// - `datagram-too-large`:      The datagram is too large. (EMSGSIZE)
///
/// # References
/// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/sendto.html>
/// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/sendmsg.html>
/// - <https://man7.org/linux/man-pages/man2/send.2.html>
/// - <https://man7.org/linux/man-pages/man2/sendmmsg.2.html>
/// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-send>
/// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-sendto>
/// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-wsasendmsg>
/// - <https://man.freebsd.org/cgi/man.cgi?query=send&sektion=2>
pub fn OutgoingDatagramStream::send(
  self : OutgoingDatagramStream,
  datagrams : Array[OutgoingDatagram]
) -> Result[UInt64, @network.ErrorCode] {
  let cleanupList : Array[@ffi.Cleanup] = []
  let ignoreList : Array[&@ffi.Any] = []
  let OutgoingDatagramStream(handle) = self
  let address = @ffi.malloc(datagrams.length() * 44)
  for index = 0; index < datagrams.length(); index = index + 1 {
    let element : OutgoingDatagram = datagrams[index]
    let base = address + index * 44
    @ffi.store32(base + 4, element.data.length())
    @ffi.store32(base + 0, @ffi.bytes2ptr(element.data))
    match element.remote_address {
      None => {
        @ffi.store8(base + 8, 0)
        ()
      }
      Some(payload4) => {
        @ffi.store8(base + 8, 1)
        match payload4 {
          Ipv4(payload7) => {
            @ffi.store8(base + 12, 0)
            @ffi.store16(base + 16, payload7.port.reinterpret_as_int())
            @ffi.store8(base + 18, payload7.address.0.to_int())
            @ffi.store8(base + 19, payload7.address.1.to_int())
            @ffi.store8(base + 20, payload7.address.2.to_int())
            @ffi.store8(base + 21, payload7.address.3.to_int())
            ()
          }
          Ipv6(payload10) => {
            @ffi.store8(base + 12, 1)
            @ffi.store16(base + 16, payload10.port.reinterpret_as_int())
            @ffi.store32(base + 20, payload10.flow_info.reinterpret_as_int())
            @ffi.store16(base + 24, payload10.address.0.reinterpret_as_int())
            @ffi.store16(base + 26, payload10.address.1.reinterpret_as_int())
            @ffi.store16(base + 28, payload10.address.2.reinterpret_as_int())
            @ffi.store16(base + 30, payload10.address.3.reinterpret_as_int())
            @ffi.store16(base + 32, payload10.address.4.reinterpret_as_int())
            @ffi.store16(base + 34, payload10.address.5.reinterpret_as_int())
            @ffi.store16(base + 36, payload10.address.6.reinterpret_as_int())
            @ffi.store16(base + 38, payload10.address.7.reinterpret_as_int())
            @ffi.store32(base + 40, payload10.scope_id.reinterpret_as_int())
            ()
          }
        }
        ()
      }
    }
    ignoreList.push(element.data)
  }
  let return_area = @ffi.malloc(16)
  wasmImportMethodOutgoingDatagramStreamSend(
    handle,
    address,
    datagrams.length(),
    return_area,
  )
  let lifted = match @ffi.load8_u(return_area + 0) {
    0 => Result::Ok(@ffi.load64(return_area + 8).reinterpret_as_uint64())
    1 => Result::Err(@network.ErrorCode::from(@ffi.load8_u(return_area + 8)))
    _ => panic()
  }
  @ffi.free(address)
  @ffi.free(return_area)
  cleanupList.each(fn(cleanup) { @ffi.free(cleanup.address) })
  ignore(ignoreList)
  return lifted
}

///| Create a `pollable` which will resolve once the stream is ready to send again.
///
/// Note: this function is here for WASI Preview2 only.
/// It's planned to be removed when `future` is natively supported in Preview3.
pub fn OutgoingDatagramStream::subscribe(
  self : OutgoingDatagramStream
) -> @poll.Pollable {
  let OutgoingDatagramStream(handle) = self
  let result : Int = wasmImportMethodOutgoingDatagramStreamSubscribe(handle)
  return @poll.Pollable::Pollable(result)
}
