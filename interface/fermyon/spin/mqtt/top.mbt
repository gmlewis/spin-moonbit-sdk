// Generated by `wit-bindgen` 0.43.0. DO NOT EDIT!

///|
/// Errors related to interacting with Mqtt
pub(all) enum Error_ {
  InvalidAddress
  TooManyConnections
  ConnectionFailed(String)
  Other(String)
} derive(Show, Eq)

///|
/// QoS for publishing Mqtt messages
pub(all) enum Qos {
  AT_MOST_ONCE
  AT_LEAST_ONCE
  EXACTLY_ONCE
} derive(Show, Eq)

///|
pub fn Qos::ordinal(self : Qos) -> Int {
  match self {
    AT_MOST_ONCE => 0
    AT_LEAST_ONCE => 1
    EXACTLY_ONCE => 2
  }
}

///|
pub fn Qos::from(self : Int) -> Qos {
  match self {
    0 => AT_MOST_ONCE
    1 => AT_LEAST_ONCE
    2 => EXACTLY_ONCE
    _ => panic()
  }
}

///|
pub(all) struct Connection(Int) derive(Show, Eq)

///|
/// Drops a resource handle.
pub fn Connection::drop(self : Connection) -> Unit {
  let Connection(resource) = self
  wasmImportResourceDropConnection(resource)
}

///|
/// Open a connection to the Mqtt instance at `address`.
pub fn Connection::open(
  address : String,
  username : String,
  password : String,
  keep_alive_interval_in_secs : UInt64,
) -> Result[Connection, Error_] {
  let return_area = @ffi.malloc(16)
  wasmImportStaticConnectionOpen(
    @ffi.str2ptr(address),
    address.length(),
    @ffi.str2ptr(username),
    username.length(),
    @ffi.str2ptr(password),
    password.length(),
    keep_alive_interval_in_secs.reinterpret_as_int64(),
    return_area,
  )
  let lifted11 = match @ffi.load8_u(return_area + 0) {
    0 => Result::Ok(Connection::Connection(@ffi.load32(return_area + 4)))
    1 => {
      let lifted = match @ffi.load8_u(return_area + 4) {
        0 => Error_::InvalidAddress
        1 => Error_::TooManyConnections
        2 => {
          let result = @ffi.ptr2str(
            @ffi.load32(return_area + 8),
            @ffi.load32(return_area + 12),
          )
          Error_::ConnectionFailed(result)
        }
        3 => {
          let result10 = @ffi.ptr2str(
            @ffi.load32(return_area + 8),
            @ffi.load32(return_area + 12),
          )
          Error_::Other(result10)
        }
        _ => panic()
      }
      Result::Err(lifted)
    }
    _ => panic()
  }
  ignore(address)
  ignore(username)
  ignore(password)
  @ffi.free(return_area)
  return lifted11
}

///|
/// Publish an Mqtt message to the specified `topic`.
pub fn Connection::publish(
  self : Connection,
  topic : String,
  payload : FixedArray[Byte],
  qos : Qos,
) -> Result[Unit, Error_] {
  let Connection(handle) = self
  let return_area = @ffi.malloc(16)
  wasmImportMethodConnectionPublish(
    handle,
    @ffi.str2ptr(topic),
    topic.length(),
    @ffi.bytes2ptr(payload),
    payload.length(),
    qos.ordinal(),
    return_area,
  )
  let lifted11 = match @ffi.load8_u(return_area + 0) {
    0 => Result::Ok(())
    1 => {
      let lifted = match @ffi.load8_u(return_area + 4) {
        0 => Error_::InvalidAddress
        1 => Error_::TooManyConnections
        2 => {
          let result = @ffi.ptr2str(
            @ffi.load32(return_area + 8),
            @ffi.load32(return_area + 12),
          )
          Error_::ConnectionFailed(result)
        }
        3 => {
          let result10 = @ffi.ptr2str(
            @ffi.load32(return_area + 8),
            @ffi.load32(return_area + 12),
          )
          Error_::Other(result10)
        }
        _ => panic()
      }
      Result::Err(lifted)
    }
    _ => panic()
  }
  ignore(topic)
  ignore(payload)
  @ffi.free(return_area)
  return lifted11
}
