// Generated by `wit-bindgen` 0.29.0. DO NOT EDIT!

///|
/// `pollable` represents a single I/O event which may be ready, or not.
pub(all) type Pollable Int derive(Show, Eq)

///|
fn wasmImportResourceDropPollable(resource : Int) = "wasi:io/poll@0.2.0" "[resource-drop]pollable"

///|
pub fn Pollable::drop(self : Pollable) -> Unit {
  wasmImportResourceDropPollable(self._)
}

///|
/// Return the readiness of a pollable. This function never blocks.
///
/// Returns `true` when the pollable is ready, and `false` otherwise.
pub fn Pollable::ready(self : Pollable) -> Bool {
  let result : Int = wasmImportMethodPollableReady(self._)
  return result != 0
}

///|
/// `block` returns immediately if the pollable is ready, and otherwise
/// blocks until ready.
///
/// This function is equivalent to calling `poll.poll` on a list
/// containing only this pollable.
pub fn Pollable::block(self : Pollable) -> Unit {
  wasmImportMethodPollableBlock(self._)
}

///|
/// Poll for completion on a set of pollables.
///
/// This function takes a list of pollables, which identify I/O sources of
/// interest, and waits until one or more of the events is ready for I/O.
///
/// The result `list<u32>` contains one or more indices of handles in the
/// argument list that is ready for I/O.
///
/// If the list contains more elements than can be indexed with a `u32`
/// value, this function traps.
///
/// A timeout can be implemented by adding a pollable from the
/// wasi-clocks API to the list.
///
/// This function does not return a `result`; polling in itself does not
/// do any I/O so it doesn't fail. If any of the I/O sources identified by
/// the pollables has an error, it is indicated by marking the source as
/// being reaedy for I/O.
pub fn poll(in_ : Array[Pollable]) -> FixedArray[UInt] {
  let address = @ffi.malloc(in_.length() * 4)
  for index = 0; index < in_.length(); index = index + 1 {
    let element : Pollable = in_[index]
    let base = address + index * 4
    @ffi.store32(base + 0, element._)
  }
  let return_area = @ffi.malloc(8)
  wasmImportPoll(address, in_.length(), return_area)
  let result = @ffi.ptr2uint_array(@ffi.load32(return_area + 0))
  @ffi.free(address)
  @ffi.free(return_area)
  return result
}
