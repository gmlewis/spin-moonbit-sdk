// Generated by `wit-bindgen` 0.29._. DO NOT EDIT!

///|
/// The type of a filesystem object referenced by a descriptor.
///
/// Note: This was called `filetype` in earlier versions of WASI.
pub(all) enum DescriptorType {
  UNKNOWN
  BLOCK_DEVICE
  CHARACTER_DEVICE
  DIRECTORY
  FIFO
  SYMBOLIC_LINK
  REGULAR_FILE
  SOCKET
} derive(Show, Eq)

///|
pub fn ordinal(self : DescriptorType) -> Int {
  match self {
    UNKNOWN => 0
    BLOCK_DEVICE => 1
    CHARACTER_DEVICE => 2
    DIRECTORY => 3
    FIFO => 4
    SYMBOLIC_LINK => 5
    REGULAR_FILE => 6
    SOCKET => 7
  }
}

///|
pub fn DescriptorType::from(self : Int) -> DescriptorType {
  match self {
    0 => UNKNOWN
    1 => BLOCK_DEVICE
    2 => CHARACTER_DEVICE
    3 => DIRECTORY
    4 => FIFO
    5 => SYMBOLIC_LINK
    6 => REGULAR_FILE
    7 => SOCKET
    _ => panic()
  }
}

///|
/// Descriptor flags.
///
/// Note: This was called `fdflags` in earlier versions of WASI.
pub(all) type DescriptorFlags Byte derive(Show, Eq)

///|
pub fn DescriptorFlags::default() -> DescriptorFlags {
  b'\x00'
}

///|
pub(all) enum DescriptorFlagsFlag {
  READ
  WRITE
  FILE_INTEGRITY_SYNC
  DATA_INTEGRITY_SYNC
  REQUESTED_WRITE_SYNC
  MUTATE_DIRECTORY
}

///|
fn DescriptorFlagsFlag::value(self : DescriptorFlagsFlag) -> Byte {
  match self {
    READ => (1U << 0).to_byte()
    WRITE => (1U << 1).to_byte()
    FILE_INTEGRITY_SYNC => (1U << 2).to_byte()
    DATA_INTEGRITY_SYNC => (1U << 3).to_byte()
    REQUESTED_WRITE_SYNC => (1U << 4).to_byte()
    MUTATE_DIRECTORY => (1U << 5).to_byte()
  }
}

///|
pub fn DescriptorFlags::set(
  self : DescriptorFlags,
  other : DescriptorFlagsFlag
) -> DescriptorFlags {
  self._ | other.value()
}

///|
pub fn DescriptorFlags::unset(
  self : DescriptorFlags,
  other : DescriptorFlagsFlag
) -> DescriptorFlags {
  self._ & other.value().lnot()
}

///|
pub fn DescriptorFlags::is_set(
  self : DescriptorFlags,
  other : DescriptorFlagsFlag
) -> Bool {
  (self._ & other.value()) == other.value()
}

///|
/// Flags determining the method of how paths are resolved.
pub(all) type PathFlags Byte derive(Show, Eq)

///|
pub fn PathFlags::default() -> PathFlags {
  b'\x00'
}

///|
pub(all) enum PathFlagsFlag {
  SYMLINK_FOLLOW
}

///|
fn PathFlagsFlag::value(self : PathFlagsFlag) -> Byte {
  match self {
    SYMLINK_FOLLOW => (1U << 0).to_byte()
  }
}

///|
pub fn PathFlags::set(self : PathFlags, other : PathFlagsFlag) -> PathFlags {
  self._ | other.value()
}

///|
pub fn PathFlags::unset(self : PathFlags, other : PathFlagsFlag) -> PathFlags {
  self._ & other.value().lnot()
}

///|
pub fn PathFlags::is_set(self : PathFlags, other : PathFlagsFlag) -> Bool {
  (self._ & other.value()) == other.value()
}

///|
/// Open flags used by `open-at`.
pub(all) type OpenFlags Byte derive(Show, Eq)

///|
pub fn OpenFlags::default() -> OpenFlags {
  b'\x00'
}

///|
pub(all) enum OpenFlagsFlag {
  CREATE
  DIRECTORY
  EXCLUSIVE
  TRUNCATE
}

///|
fn OpenFlagsFlag::value(self : OpenFlagsFlag) -> Byte {
  match self {
    CREATE => (1U << 0).to_byte()
    DIRECTORY => (1U << 1).to_byte()
    EXCLUSIVE => (1U << 2).to_byte()
    TRUNCATE => (1U << 3).to_byte()
  }
}

///|
pub fn OpenFlags::set(self : OpenFlags, other : OpenFlagsFlag) -> OpenFlags {
  self._ | other.value()
}

///|
pub fn OpenFlags::unset(self : OpenFlags, other : OpenFlagsFlag) -> OpenFlags {
  self._ & other.value().lnot()
}

///|
pub fn OpenFlags::is_set(self : OpenFlags, other : OpenFlagsFlag) -> Bool {
  (self._ & other.value()) == other.value()
}

///|
/// File attributes.
///
/// Note: This was called `filestat` in earlier versions of WASI.
pub(all) struct DescriptorStat {
  type_ : DescriptorType
  link_count : UInt64
  size : UInt64
  data_access_timestamp : @wallClock.Datetime?
  data_modification_timestamp : @wallClock.Datetime?
  status_change_timestamp : @wallClock.Datetime?
} derive(Show, Eq)

///|
/// When setting a timestamp, this gives the value to set it to.
pub(all) enum NewTimestamp {
  NoChange
  Now
  Timestamp(@wallClock.Datetime)
} derive(Show, Eq)

///|
/// A directory entry.
pub(all) struct DirectoryEntry {
  type_ : DescriptorType
  name : String
} derive(Show, Eq)

///|
/// Error codes returned by functions, similar to `errno` in POSIX.
/// Not all of these error codes are returned by the functions provided by this
/// API; some are used in higher-level library layers, and others are provided
/// merely for alignment with POSIX.
pub(all) enum ErrorCode {
  ACCESS
  WOULD_BLOCK
  ALREADY
  BAD_DESCRIPTOR
  BUSY
  DEADLOCK
  QUOTA
  EXIST
  FILE_TOO_LARGE
  ILLEGAL_BYTE_SEQUENCE
  IN_PROGRESS
  INTERRUPTED
  INVALID
  IO
  IS_DIRECTORY
  LOOP
  TOO_MANY_LINKS
  MESSAGE_SIZE
  NAME_TOO_LONG
  NO_DEVICE
  NO_ENTRY
  NO_LOCK
  INSUFFICIENT_MEMORY
  INSUFFICIENT_SPACE
  NOT_DIRECTORY
  NOT_EMPTY
  NOT_RECOVERABLE
  UNSUPPORTED
  NO_TTY
  NO_SUCH_DEVICE
  OVERFLOW
  NOT_PERMITTED
  PIPE
  READ_ONLY
  INVALID_SEEK
  TEXT_FILE_BUSY
  CROSS_DEVICE
} derive(Show, Eq)

///|
pub fn ErrorCode::ordinal(self : ErrorCode) -> Int {
  match self {
    ACCESS => 0
    WOULD_BLOCK => 1
    ALREADY => 2
    BAD_DESCRIPTOR => 3
    BUSY => 4
    DEADLOCK => 5
    QUOTA => 6
    EXIST => 7
    FILE_TOO_LARGE => 8
    ILLEGAL_BYTE_SEQUENCE => 9
    IN_PROGRESS => 10
    INTERRUPTED => 11
    INVALID => 12
    IO => 13
    IS_DIRECTORY => 14
    LOOP => 15
    TOO_MANY_LINKS => 16
    MESSAGE_SIZE => 17
    NAME_TOO_LONG => 18
    NO_DEVICE => 19
    NO_ENTRY => 20
    NO_LOCK => 21
    INSUFFICIENT_MEMORY => 22
    INSUFFICIENT_SPACE => 23
    NOT_DIRECTORY => 24
    NOT_EMPTY => 25
    NOT_RECOVERABLE => 26
    UNSUPPORTED => 27
    NO_TTY => 28
    NO_SUCH_DEVICE => 29
    OVERFLOW => 30
    NOT_PERMITTED => 31
    PIPE => 32
    READ_ONLY => 33
    INVALID_SEEK => 34
    TEXT_FILE_BUSY => 35
    CROSS_DEVICE => 36
  }
}

///|
pub fn ErrorCode::from(self : Int) -> ErrorCode {
  match self {
    0 => ACCESS
    1 => WOULD_BLOCK
    2 => ALREADY
    3 => BAD_DESCRIPTOR
    4 => BUSY
    5 => DEADLOCK
    6 => QUOTA
    7 => EXIST
    8 => FILE_TOO_LARGE
    9 => ILLEGAL_BYTE_SEQUENCE
    10 => IN_PROGRESS
    11 => INTERRUPTED
    12 => INVALID
    13 => IO
    14 => IS_DIRECTORY
    15 => LOOP
    16 => TOO_MANY_LINKS
    17 => MESSAGE_SIZE
    18 => NAME_TOO_LONG
    19 => NO_DEVICE
    20 => NO_ENTRY
    21 => NO_LOCK
    22 => INSUFFICIENT_MEMORY
    23 => INSUFFICIENT_SPACE
    24 => NOT_DIRECTORY
    25 => NOT_EMPTY
    26 => NOT_RECOVERABLE
    27 => UNSUPPORTED
    28 => NO_TTY
    29 => NO_SUCH_DEVICE
    30 => OVERFLOW
    31 => NOT_PERMITTED
    32 => PIPE
    33 => READ_ONLY
    34 => INVALID_SEEK
    35 => TEXT_FILE_BUSY
    36 => CROSS_DEVICE
    _ => panic()
  }
}

///|
/// File or memory access pattern advisory information.
pub(all) enum Advice {
  NORMAL
  SEQUENTIAL
  RANDOM
  WILL_NEED
  DONT_NEED
  NO_REUSE
} derive(Show, Eq)

///|
pub fn Advice::ordinal(self : Advice) -> Int {
  match self {
    NORMAL => 0
    SEQUENTIAL => 1
    RANDOM => 2
    WILL_NEED => 3
    DONT_NEED => 4
    NO_REUSE => 5
  }
}

///|
pub fn Advice::from(self : Int) -> Advice {
  match self {
    0 => NORMAL
    1 => SEQUENTIAL
    2 => RANDOM
    3 => WILL_NEED
    4 => DONT_NEED
    5 => NO_REUSE
    _ => panic()
  }
}

///|
/// A 128-bit hash value, split into parts because wasm doesn't have a
/// 128-bit integer type.
pub(all) struct MetadataHashValue {
  lower : UInt64
  upper : UInt64
} derive(Show, Eq)

///|
/// A descriptor is a reference to a filesystem object, which may be a file,
/// directory, named pipe, special file, or other object on which filesystem
/// calls may be made.
pub(all) type Descriptor Int derive(Show, Eq)

///|
fn wasmImportResourceDropDescriptor(resource : Int) = "wasi:filesystem/types@0.2.0" "[resource-drop]descriptor"

///|
pub fn Descriptor::drop(self : Descriptor) -> Unit {
  wasmImportResourceDropDescriptor(self._)
}

///|
/// A stream of directory entries.
pub(all) type DirectoryEntryStream Int derive(Show, Eq)

///|
fn wasmImportResourceDropDirectoryEntryStream(resource : Int) = "wasi:filesystem/types@0.2.0" "[resource-drop]directory-entry-stream"

///|
pub fn DirectoryEntryStream::drop(self : DirectoryEntryStream) -> Unit {
  wasmImportResourceDropDirectoryEntryStream(self._)
}

///|
/// Return a stream for reading from a file, if available.
///
/// May fail with an error-code describing why the file cannot be read.
///
/// Multiple read, write, and append streams may be active on the same open
/// file and they do not interfere with each other.
///
/// Note: This allows using `read-stream`, which is similar to `read` in POSIX.
pub fn Descriptor::read_via_stream(
  self : Descriptor,
  offset : UInt64
) -> Result[@streams.InputStream, ErrorCode] {
  let return_area = @ffi.malloc(8)
  wasmImportMethodDescriptorReadViaStream(
    self._,
    offset.reinterpret_as_int64(),
    return_area,
  )
  let lifted = match @ffi.load8_u(return_area + 0) {
    0 =>
      Result::Ok(
        @streams.InputStream::InputStream(@ffi.load32(return_area + 4)),
      )
    1 => Result::Err(ErrorCode::from(@ffi.load8_u(return_area + 4)))
    _ => panic()
  }
  @ffi.free(return_area)
  return lifted
}

///|
/// Return a stream for writing to a file, if available.
///
/// May fail with an error-code describing why the file cannot be written.
///
/// Note: This allows using `write-stream`, which is similar to `write` in
/// POSIX.
pub fn Descriptor::write_via_stream(
  self : Descriptor,
  offset : UInt64
) -> Result[@streams.OutputStream, ErrorCode] {
  let return_area = @ffi.malloc(8)
  wasmImportMethodDescriptorWriteViaStream(
    self._,
    offset.reinterpret_as_int64(),
    return_area,
  )
  let lifted = match @ffi.load8_u(return_area + 0) {
    0 =>
      Result::Ok(
        @streams.OutputStream::OutputStream(@ffi.load32(return_area + 4)),
      )
    1 => Result::Err(ErrorCode::from(@ffi.load8_u(return_area + 4)))
    _ => panic()
  }
  @ffi.free(return_area)
  return lifted
}

///|
/// Return a stream for appending to a file, if available.
///
/// May fail with an error-code describing why the file cannot be appended.
///
/// Note: This allows using `write-stream`, which is similar to `write` with
/// `O_APPEND` in in POSIX.
pub fn Descriptor::append_via_stream(
  self : Descriptor
) -> Result[@streams.OutputStream, ErrorCode] {
  let return_area = @ffi.malloc(8)
  wasmImportMethodDescriptorAppendViaStream(self._, return_area)
  let lifted = match @ffi.load8_u(return_area + 0) {
    0 =>
      Result::Ok(
        @streams.OutputStream::OutputStream(@ffi.load32(return_area + 4)),
      )
    1 => Result::Err(ErrorCode::from(@ffi.load8_u(return_area + 4)))
    _ => panic()
  }
  @ffi.free(return_area)
  return lifted
}

///|
/// Provide file advisory information on a descriptor.
///
/// This is similar to `posix_fadvise` in POSIX.
pub fn Descriptor::advise(
  self : Descriptor,
  offset : UInt64,
  length : UInt64,
  advice : Advice
) -> Result[Unit, ErrorCode] {
  let return_area = @ffi.malloc(2)
  wasmImportMethodDescriptorAdvise(
    self._,
    offset.reinterpret_as_int64(),
    length.reinterpret_as_int64(),
    advice.ordinal(),
    return_area,
  )
  let lifted = match @ffi.load8_u(return_area + 0) {
    0 => Result::Ok(())
    1 => Result::Err(ErrorCode::from(@ffi.load8_u(return_area + 1)))
    _ => panic()
  }
  @ffi.free(return_area)
  return lifted
}

///|
/// Synchronize the data of a file to disk.
///
/// This function succeeds with no effect if the file descriptor is not
/// opened for writing.
///
/// Note: This is similar to `fdatasync` in POSIX.
pub fn Descriptor::sync_data(self : Descriptor) -> Result[Unit, ErrorCode] {
  let return_area = @ffi.malloc(2)
  wasmImportMethodDescriptorSyncData(self._, return_area)
  let lifted = match @ffi.load8_u(return_area + 0) {
    0 => Result::Ok(())
    1 => Result::Err(ErrorCode::from(@ffi.load8_u(return_area + 1)))
    _ => panic()
  }
  @ffi.free(return_area)
  return lifted
}

///|
/// Get flags associated with a descriptor.
///
/// Note: This returns similar flags to `fcntl(fd, F_GETFL)` in POSIX.
///
/// Note: This returns the value that was the `fs_flags` value returned
/// from `fdstat_get` in earlier versions of WASI.
pub fn Descriptor::get_flags(
  self : Descriptor
) -> Result[DescriptorFlags, ErrorCode] {
  let return_area = @ffi.malloc(2)
  wasmImportMethodDescriptorGetFlags(self._, return_area)
  let lifted = match @ffi.load8_u(return_area + 0) {
    0 => Result::Ok(DescriptorFlags(@ffi.load8_u(return_area + 1).to_byte()))
    1 => Result::Err(ErrorCode::from(@ffi.load8_u(return_area + 1)))
    _ => panic()
  }
  @ffi.free(return_area)
  return lifted
}

///|
/// Get the dynamic type of a descriptor.
///
/// Note: This returns the same value as the `type` field of the `fd-stat`
/// returned by `stat`, `stat-at` and similar.
///
/// Note: This returns similar flags to the `st_mode & S_IFMT` value provided
/// by `fstat` in POSIX.
///
/// Note: This returns the value that was the `fs_filetype` value returned
/// from `fdstat_get` in earlier versions of WASI.
pub fn Descriptor::get_type(
  self : Descriptor
) -> Result[DescriptorType, ErrorCode] {
  let return_area = @ffi.malloc(2)
  wasmImportMethodDescriptorGetType(self._, return_area)
  let lifted = match @ffi.load8_u(return_area + 0) {
    0 => Result::Ok(DescriptorType::from(@ffi.load8_u(return_area + 1)))
    1 => Result::Err(ErrorCode::from(@ffi.load8_u(return_area + 1)))
    _ => panic()
  }
  @ffi.free(return_area)
  return lifted
}

///|
/// Adjust the size of an open file. If this increases the file's size, the
/// extra bytes are filled with zeros.
///
/// Note: This was called `fd_filestat_set_size` in earlier versions of WASI.
pub fn Descriptor::set_size(
  self : Descriptor,
  size : UInt64
) -> Result[Unit, ErrorCode] {
  let return_area = @ffi.malloc(2)
  wasmImportMethodDescriptorSetSize(
    self._,
    size.reinterpret_as_int64(),
    return_area,
  )
  let lifted = match @ffi.load8_u(return_area + 0) {
    0 => Result::Ok(())
    1 => Result::Err(ErrorCode::from(@ffi.load8_u(return_area + 1)))
    _ => panic()
  }
  @ffi.free(return_area)
  return lifted
}

///|
/// Adjust the timestamps of an open file or directory.
///
/// Note: This is similar to `futimens` in POSIX.
///
/// Note: This was called `fd_filestat_set_times` in earlier versions of WASI.
pub fn Descriptor::set_times(
  self : Descriptor,
  data_access_timestamp : NewTimestamp,
  data_modification_timestamp : NewTimestamp
) -> Result[Unit, ErrorCode] {
  let (lowered, lowered6, lowered7) = match data_access_timestamp {
    NoChange => (0, 0L, 0)
    Now => (1, 0L, 0)
    Timestamp(payload5) =>
      (
        2,
        payload5.seconds.reinterpret_as_int64(),
        payload5.nanoseconds.reinterpret_as_int(),
      )
    // _ => panic()
  }
  let (lowered17, lowered18, lowered19) = match data_modification_timestamp {
    NoChange => (0, 0L, 0)
    Now => (1, 0L, 0)
    Timestamp(payload16) =>
      (
        2,
        payload16.seconds.reinterpret_as_int64(),
        payload16.nanoseconds.reinterpret_as_int(),
      )
    // _ => panic()
  }
  let return_area = @ffi.malloc(2)
  wasmImportMethodDescriptorSetTimes(
    self._,
    lowered,
    lowered6,
    lowered7,
    lowered17,
    lowered18,
    lowered19,
    return_area,
  )
  let lifted = match @ffi.load8_u(return_area + 0) {
    0 => Result::Ok(())
    1 => Result::Err(ErrorCode::from(@ffi.load8_u(return_area + 1)))
    _ => panic()
  }
  @ffi.free(return_area)
  return lifted
}

///|
/// Read from a descriptor, without using and updating the descriptor's offset.
///
/// This function returns a list of bytes containing the data that was
/// read, along with a bool which, when true, indicates that the end of the
/// file was reached. The returned list will contain up to `length` bytes; it
/// may return fewer than requested, if the end of the file is reached or
/// if the I/O operation is interrupted.
///
/// In the future, this may change to return a `stream<u8, error-code>`.
///
/// Note: This is similar to `pread` in POSIX.
pub fn Descriptor::read(
  self : Descriptor,
  length : UInt64,
  offset : UInt64
) -> Result[(Bytes, Bool), ErrorCode] {
  let return_area = @ffi.malloc(16)
  wasmImportMethodDescriptorRead(
    self._,
    length.reinterpret_as_int64(),
    offset.reinterpret_as_int64(),
    return_area,
  )
  let lifted = match @ffi.load8_u(return_area + 0) {
    0 => {
      let result = @ffi.ptr2bytes(@ffi.load32(return_area + 4))
      Result::Ok((result, @ffi.load8_u(return_area + 12) != 0))
    }
    1 => Result::Err(ErrorCode::from(@ffi.load8_u(return_area + 4)))
    _ => panic()
  }
  @ffi.free(return_area)
  return lifted
}

///|
/// Write to a descriptor, without using and updating the descriptor's offset.
///
/// It is valid to write past the end of a file; the file is extended to the
/// extent of the write, with bytes between the previous end and the start of
/// the write set to zero.
///
/// In the future, this may change to take a `stream<u8, error-code>`.
///
/// Note: This is similar to `pwrite` in POSIX.
pub fn Descriptor::write(
  self : Descriptor,
  buffer : Bytes,
  offset : UInt64
) -> Result[UInt64, ErrorCode] {
  let return_area = @ffi.malloc(16)
  wasmImportMethodDescriptorWrite(
    self._,
    @ffi.bytes2ptr(buffer),
    buffer.length(),
    offset.reinterpret_as_int64(),
    return_area,
  )
  let lifted = match @ffi.load8_u(return_area + 0) {
    0 => Result::Ok(@ffi.load64(return_area + 8).reinterpret_as_uint64())
    1 => Result::Err(ErrorCode::from(@ffi.load8_u(return_area + 8)))
    _ => panic()
  }
  ignore(buffer)
  @ffi.free(return_area)
  return lifted
}

///|
/// Read directory entries from a directory.
///
/// On filesystems where directories contain entries referring to themselves
/// and their parents, often named `.` and `..` respectively, these entries
/// are omitted.
///
/// This always returns a new stream which starts at the beginning of the
/// directory. Multiple streams may be active on the same directory, and they
/// do not interfere with each other.
pub fn Descriptor::read_directory(
  self : Descriptor
) -> Result[DirectoryEntryStream, ErrorCode] {
  let return_area = @ffi.malloc(8)
  wasmImportMethodDescriptorReadDirectory(self._, return_area)
  let lifted = match @ffi.load8_u(return_area + 0) {
    0 =>
      Result::Ok(
        DirectoryEntryStream::DirectoryEntryStream(@ffi.load32(return_area + 4)),
      )
    1 => Result::Err(ErrorCode::from(@ffi.load8_u(return_area + 4)))
    _ => panic()
  }
  @ffi.free(return_area)
  return lifted
}

///|
/// Synchronize the data and metadata of a file to disk.
///
/// This function succeeds with no effect if the file descriptor is not
/// opened for writing.
///
/// Note: This is similar to `fsync` in POSIX.
pub fn Descriptor::sync(self : Descriptor) -> Result[Unit, ErrorCode] {
  let return_area = @ffi.malloc(2)
  wasmImportMethodDescriptorSync(self._, return_area)
  let lifted = match @ffi.load8_u(return_area + 0) {
    0 => Result::Ok(())
    1 => Result::Err(ErrorCode::from(@ffi.load8_u(return_area + 1)))
    _ => panic()
  }
  @ffi.free(return_area)
  return lifted
}

///|
/// Create a directory.
///
/// Note: This is similar to `mkdirat` in POSIX.
pub fn Descriptor::create_directory_at(
  self : Descriptor,
  path : String
) -> Result[Unit, ErrorCode] {
  let return_area = @ffi.malloc(2)
  wasmImportMethodDescriptorCreateDirectoryAt(
    self._,
    @ffi.str2ptr(path),
    path.iter().count(),
    return_area,
  )
  let lifted = match @ffi.load8_u(return_area + 0) {
    0 => Result::Ok(())
    1 => Result::Err(ErrorCode::from(@ffi.load8_u(return_area + 1)))
    _ => panic()
  }
  ignore(path)
  @ffi.free(return_area)
  return lifted
}

///|
/// Return the attributes of an open file or directory.
///
/// Note: This is similar to `fstat` in POSIX, except that it does not return
/// device and inode information. For testing whether two descriptors refer to
/// the same underlying filesystem object, use `is-same-object`. To obtain
/// additional data that can be used do determine whether a file has been
/// modified, use `metadata-hash`.
///
/// Note: This was called `fd_filestat_get` in earlier versions of WASI.
pub fn Descriptor::stat(self : Descriptor) -> Result[DescriptorStat, ErrorCode] {
  let return_area = @ffi.malloc(104)
  wasmImportMethodDescriptorStat(self._, return_area)
  let lifted16 = match @ffi.load8_u(return_area + 0) {
    0 => {
      let lifted : @wallClock.Datetime? = match @ffi.load8_u(return_area + 32) {
        0 => Option::None
        1 =>
          Option::Some(@wallClock.Datetime::{
            seconds: @ffi.load64(return_area + 40).reinterpret_as_uint64(),
            nanoseconds: @ffi.load32(return_area + 48).reinterpret_as_uint(),
          })
        _ => panic()
      }
      let lifted8 : @wallClock.Datetime? = match
        @ffi.load8_u(return_area + 56) {
        0 => Option::None
        1 =>
          Option::Some(@wallClock.Datetime::{
            seconds: @ffi.load64(return_area + 64).reinterpret_as_uint64(),
            nanoseconds: @ffi.load32(return_area + 72).reinterpret_as_uint(),
          })
        _ => panic()
      }
      let lifted13 : @wallClock.Datetime? = match
        @ffi.load8_u(return_area + 80) {
        0 => Option::None
        1 =>
          Option::Some(@wallClock.Datetime::{
            seconds: @ffi.load64(return_area + 88).reinterpret_as_uint64(),
            nanoseconds: @ffi.load32(return_area + 96).reinterpret_as_uint(),
          })
        _ => panic()
      }
      Result::Ok(DescriptorStat::{
        type_: DescriptorType::from(@ffi.load8_u(return_area + 8)),
        link_count: @ffi.load64(return_area + 16).reinterpret_as_uint64(),
        size: @ffi.load64(return_area + 24).reinterpret_as_uint64(),
        data_access_timestamp: lifted,
        data_modification_timestamp: lifted8,
        status_change_timestamp: lifted13,
      })
    }
    1 => Result::Err(ErrorCode::from(@ffi.load8_u(return_area + 8)))
    _ => panic()
  }
  @ffi.free(return_area)
  return lifted16
}

///|
/// Return the attributes of a file or directory.
///
/// Note: This is similar to `fstatat` in POSIX, except that it does not
/// return device and inode information. See the `stat` description for a
/// discussion of alternatives.
///
/// Note: This was called `path_filestat_get` in earlier versions of WASI.
pub fn Descriptor::stat_at(
  self : Descriptor,
  path_flags : PathFlags,
  path : String
) -> Result[DescriptorStat, ErrorCode] {
  let return_area = @ffi.malloc(104)
  wasmImportMethodDescriptorStatAt(
    self._,
    path_flags._.to_int(),
    @ffi.str2ptr(path),
    path.iter().count(),
    return_area,
  )
  let lifted16 = match @ffi.load8_u(return_area + 0) {
    0 => {
      let lifted : @wallClock.Datetime? = match @ffi.load8_u(return_area + 32) {
        0 => Option::None
        1 =>
          Option::Some(@wallClock.Datetime::{
            seconds: @ffi.load64(return_area + 40).reinterpret_as_uint64(),
            nanoseconds: @ffi.load32(return_area + 48).reinterpret_as_uint(),
          })
        _ => panic()
      }
      let lifted8 : @wallClock.Datetime? = match
        @ffi.load8_u(return_area + 56) {
        0 => Option::None
        1 =>
          Option::Some(@wallClock.Datetime::{
            seconds: @ffi.load64(return_area + 64).reinterpret_as_uint64(),
            nanoseconds: @ffi.load32(return_area + 72).reinterpret_as_uint(),
          })
        _ => panic()
      }
      let lifted13 : @wallClock.Datetime? = match
        @ffi.load8_u(return_area + 80) {
        0 => Option::None
        1 =>
          Option::Some(@wallClock.Datetime::{
            seconds: @ffi.load64(return_area + 88).reinterpret_as_uint64(),
            nanoseconds: @ffi.load32(return_area + 96).reinterpret_as_uint(),
          })
        _ => panic()
      }
      Result::Ok(DescriptorStat::{
        type_: DescriptorType::from(@ffi.load8_u(return_area + 8)),
        link_count: @ffi.load64(return_area + 16).reinterpret_as_uint64(),
        size: @ffi.load64(return_area + 24).reinterpret_as_uint64(),
        data_access_timestamp: lifted,
        data_modification_timestamp: lifted8,
        status_change_timestamp: lifted13,
      })
    }
    1 => Result::Err(ErrorCode::from(@ffi.load8_u(return_area + 8)))
    _ => panic()
  }
  ignore(path)
  @ffi.free(return_area)
  return lifted16
}

///|
/// Adjust the timestamps of a file or directory.
///
/// Note: This is similar to `utimensat` in POSIX.
///
/// Note: This was called `path_filestat_set_times` in earlier versions of
/// WASI.
pub fn Descriptor::set_times_at(
  self : Descriptor,
  path_flags : PathFlags,
  path : String,
  data_access_timestamp : NewTimestamp,
  data_modification_timestamp : NewTimestamp
) -> Result[Unit, ErrorCode] {
  let (lowered, lowered6, lowered7) = match data_access_timestamp {
    NoChange => (0, 0L, 0)
    Now => (1, 0L, 0)
    Timestamp(payload5) =>
      (
        2,
        payload5.seconds.reinterpret_as_int64(),
        payload5.nanoseconds.reinterpret_as_int(),
      )
    // _ => panic()
  }
  let (lowered17, lowered18, lowered19) = match data_modification_timestamp {
    NoChange => (0, 0L, 0)
    Now => (1, 0L, 0)
    Timestamp(payload16) =>
      (
        2,
        payload16.seconds.reinterpret_as_int64(),
        payload16.nanoseconds.reinterpret_as_int(),
      )
    // _ => panic()
  }
  let return_area = @ffi.malloc(2)
  wasmImportMethodDescriptorSetTimesAt(
    self._,
    path_flags._.to_int(),
    @ffi.str2ptr(path),
    path.iter().count(),
    lowered,
    lowered6,
    lowered7,
    lowered17,
    lowered18,
    lowered19,
    return_area,
  )
  let lifted = match @ffi.load8_u(return_area + 0) {
    0 => Result::Ok(())
    1 => Result::Err(ErrorCode::from(@ffi.load8_u(return_area + 1)))
    _ => panic()
  }
  ignore(path)
  @ffi.free(return_area)
  return lifted
}

///|
/// Create a hard link.
///
/// Note: This is similar to `linkat` in POSIX.
pub fn Descriptor::link_at(
  self : Descriptor,
  old_path_flags : PathFlags,
  old_path : String,
  new_descriptor : Descriptor,
  new_path : String
) -> Result[Unit, ErrorCode] {
  let return_area = @ffi.malloc(2)
  wasmImportMethodDescriptorLinkAt(
    self._,
    old_path_flags._.to_int(),
    @ffi.str2ptr(old_path),
    old_path.iter().count(),
    new_descriptor._,
    @ffi.str2ptr(new_path),
    new_path.iter().count(),
    return_area,
  )
  let lifted = match @ffi.load8_u(return_area + 0) {
    0 => Result::Ok(())
    1 => Result::Err(ErrorCode::from(@ffi.load8_u(return_area + 1)))
    _ => panic()
  }
  ignore(old_path)
  ignore(new_path)
  @ffi.free(return_area)
  return lifted
}

///|
/// Open a file or directory.
///
/// The returned descriptor is not guaranteed to be the lowest-numbered
/// descriptor not currently open/ it is randomized to prevent applications
/// from depending on making assumptions about indexes, since this is
/// error-prone in multi-threaded contexts. The returned descriptor is
/// guaranteed to be less than 2**31.
///
/// If `flags` contains `descriptor-flags::mutate-directory`, and the base
/// descriptor doesn't have `descriptor-flags::mutate-directory` set,
/// `open-at` fails with `error-code::read-only`.
///
/// If `flags` contains `write` or `mutate-directory`, or `open-flags`
/// contains `truncate` or `create`, and the base descriptor doesn't have
/// `descriptor-flags::mutate-directory` set, `open-at` fails with
/// `error-code::read-only`.
///
/// Note: This is similar to `openat` in POSIX.
pub fn Descriptor::open_at(
  self : Descriptor,
  path_flags : PathFlags,
  path : String,
  open_flags : OpenFlags,
  flags : DescriptorFlags
) -> Result[Descriptor, ErrorCode] {
  let return_area = @ffi.malloc(8)
  wasmImportMethodDescriptorOpenAt(
    self._,
    path_flags._.to_int(),
    @ffi.str2ptr(path),
    path.iter().count(),
    open_flags._.to_int(),
    flags._.to_int(),
    return_area,
  )
  let lifted = match @ffi.load8_u(return_area + 0) {
    0 => Result::Ok(Descriptor::Descriptor(@ffi.load32(return_area + 4)))
    1 => Result::Err(ErrorCode::from(@ffi.load8_u(return_area + 4)))
    _ => panic()
  }
  ignore(path)
  @ffi.free(return_area)
  return lifted
}

///|
/// Read the contents of a symbolic link.
///
/// If the contents contain an absolute or rooted path in the underlying
/// filesystem, this function fails with `error-code::not-permitted`.
///
/// Note: This is similar to `readlinkat` in POSIX.
pub fn Descriptor::readlink_at(
  self : Descriptor,
  path : String
) -> Result[String, ErrorCode] {
  let return_area = @ffi.malloc(12)
  wasmImportMethodDescriptorReadlinkAt(
    self._,
    @ffi.str2ptr(path),
    path.iter().count(),
    return_area,
  )
  let lifted = match @ffi.load8_u(return_area + 0) {
    0 => {
      let result = @ffi.ptr2str(@ffi.load32(return_area + 4))
      Result::Ok(result)
    }
    1 => Result::Err(ErrorCode::from(@ffi.load8_u(return_area + 4)))
    _ => panic()
  }
  ignore(path)
  @ffi.free(return_area)
  return lifted
}

///|
/// Remove a directory.
///
/// Return `error-code::not-empty` if the directory is not empty.
///
/// Note: This is similar to `unlinkat(fd, path, AT_REMOVEDIR)` in POSIX.
pub fn Descriptor::remove_directory_at(
  self : Descriptor,
  path : String
) -> Result[Unit, ErrorCode] {
  let return_area = @ffi.malloc(2)
  wasmImportMethodDescriptorRemoveDirectoryAt(
    self._,
    @ffi.str2ptr(path),
    path.iter().count(),
    return_area,
  )
  let lifted = match @ffi.load8_u(return_area + 0) {
    0 => Result::Ok(())
    1 => Result::Err(ErrorCode::from(@ffi.load8_u(return_area + 1)))
    _ => panic()
  }
  ignore(path)
  @ffi.free(return_area)
  return lifted
}

///|
/// Rename a filesystem object.
///
/// Note: This is similar to `renameat` in POSIX.
pub fn Descriptor::rename_at(
  self : Descriptor,
  old_path : String,
  new_descriptor : Descriptor,
  new_path : String
) -> Result[Unit, ErrorCode] {
  let return_area = @ffi.malloc(2)
  wasmImportMethodDescriptorRenameAt(
    self._,
    @ffi.str2ptr(old_path),
    old_path.iter().count(),
    new_descriptor._,
    @ffi.str2ptr(new_path),
    new_path.iter().count(),
    return_area,
  )
  let lifted = match @ffi.load8_u(return_area + 0) {
    0 => Result::Ok(())
    1 => Result::Err(ErrorCode::from(@ffi.load8_u(return_area + 1)))
    _ => panic()
  }
  ignore(old_path)
  ignore(new_path)
  @ffi.free(return_area)
  return lifted
}

///|
/// Create a symbolic link (also known as a "symlink").
///
/// If `old-path` starts with `/`, the function fails with
/// `error-code::not-permitted`.
///
/// Note: This is similar to `symlinkat` in POSIX.
pub fn Descriptor::symlink_at(
  self : Descriptor,
  old_path : String,
  new_path : String
) -> Result[Unit, ErrorCode] {
  let return_area = @ffi.malloc(2)
  wasmImportMethodDescriptorSymlinkAt(
    self._,
    @ffi.str2ptr(old_path),
    old_path.iter().count(),
    @ffi.str2ptr(new_path),
    new_path.iter().count(),
    return_area,
  )
  let lifted = match @ffi.load8_u(return_area + 0) {
    0 => Result::Ok(())
    1 => Result::Err(ErrorCode::from(@ffi.load8_u(return_area + 1)))
    _ => panic()
  }
  ignore(old_path)
  ignore(new_path)
  @ffi.free(return_area)
  return lifted
}

///|
/// Unlink a filesystem object that is not a directory.
///
/// Return `error-code::is-directory` if the path refers to a directory.
/// Note: This is similar to `unlinkat(fd, path, 0)` in POSIX.
pub fn Descriptor::unlink_file_at(
  self : Descriptor,
  path : String
) -> Result[Unit, ErrorCode] {
  let return_area = @ffi.malloc(2)
  wasmImportMethodDescriptorUnlinkFileAt(
    self._,
    @ffi.str2ptr(path),
    path.iter().count(),
    return_area,
  )
  let lifted = match @ffi.load8_u(return_area + 0) {
    0 => Result::Ok(())
    1 => Result::Err(ErrorCode::from(@ffi.load8_u(return_area + 1)))
    _ => panic()
  }
  ignore(path)
  @ffi.free(return_area)
  return lifted
}

///|
/// Test whether two descriptors refer to the same filesystem object.
///
/// In POSIX, this corresponds to testing whether the two descriptors have the
/// same device (`st_dev`) and inode (`st_ino` or `d_ino`) numbers.
/// wasi-filesystem does not expose device and inode numbers, so this function
/// may be used instead.
pub fn Descriptor::is_same_object(
  self : Descriptor,
  other : Descriptor
) -> Bool {
  let result : Int = wasmImportMethodDescriptorIsSameObject(self._, other._)
  return result != 0
}

///|
/// Return a hash of the metadata associated with a filesystem object referred
/// to by a descriptor.
///
/// This returns a hash of the last-modification timestamp and file size, and
/// may also include the inode number, device number, birth timestamp, and
/// other metadata fields that may change when the file is modified or
/// replaced. It may also include a secret value chosen by the
/// implementation and not otherwise exposed.
///
/// Implementations are encourated to provide the following properties:
///
/// - If the file is not modified or replaced, the computed hash value should
/// usually not change.
/// - If the object is modified or replaced, the computed hash value should
/// usually change.
/// - The inputs to the hash should not be easily computable from the
/// computed hash.
///
/// However, none of these is required.
pub fn Descriptor::metadata_hash(
  self : Descriptor
) -> Result[MetadataHashValue, ErrorCode] {
  let return_area = @ffi.malloc(24)
  wasmImportMethodDescriptorMetadataHash(self._, return_area)
  let lifted = match @ffi.load8_u(return_area + 0) {
    0 =>
      Result::Ok(MetadataHashValue::{
        lower: @ffi.load64(return_area + 8).reinterpret_as_uint64(),
        upper: @ffi.load64(return_area + 16).reinterpret_as_uint64(),
      })
    1 => Result::Err(ErrorCode::from(@ffi.load8_u(return_area + 8)))
    _ => panic()
  }
  @ffi.free(return_area)
  return lifted
}

///|
/// Return a hash of the metadata associated with a filesystem object referred
/// to by a directory descriptor and a relative path.
///
/// This performs the same hash computation as `metadata-hash`.
pub fn Descriptor::metadata_hash_at(
  self : Descriptor,
  path_flags : PathFlags,
  path : String
) -> Result[MetadataHashValue, ErrorCode] {
  let return_area = @ffi.malloc(24)
  wasmImportMethodDescriptorMetadataHashAt(
    self._,
    path_flags._.to_int(),
    @ffi.str2ptr(path),
    path.iter().count(),
    return_area,
  )
  let lifted = match @ffi.load8_u(return_area + 0) {
    0 =>
      Result::Ok(MetadataHashValue::{
        lower: @ffi.load64(return_area + 8).reinterpret_as_uint64(),
        upper: @ffi.load64(return_area + 16).reinterpret_as_uint64(),
      })
    1 => Result::Err(ErrorCode::from(@ffi.load8_u(return_area + 8)))
    _ => panic()
  }
  ignore(path)
  @ffi.free(return_area)
  return lifted
}

///|
/// Read a single directory entry from a `directory-entry-stream`.
pub fn DirectoryEntryStream::read_directory_entry(
  self : DirectoryEntryStream
) -> Result[DirectoryEntry?, ErrorCode] {
  let return_area = @ffi.malloc(20)
  wasmImportMethodDirectoryEntryStreamReadDirectoryEntry(self._, return_area)
  let lifted6 = match @ffi.load8_u(return_area + 0) {
    0 => {
      let lifted : DirectoryEntry? = match @ffi.load8_u(return_area + 4) {
        0 => Option::None
        1 => {
          let result = @ffi.ptr2str(@ffi.load32(return_area + 12))
          Option::Some(DirectoryEntry::{
            type_: DescriptorType::from(@ffi.load8_u(return_area + 8)),
            name: result,
          })
        }
        _ => panic()
      }
      Result::Ok(lifted)
    }
    1 => Result::Err(ErrorCode::from(@ffi.load8_u(return_area + 4)))
    _ => panic()
  }
  @ffi.free(return_area)
  return lifted6
}

///|
/// Attempts to extract a filesystem-related `error-code` from the stream
/// `error` provided.
///
/// Stream operations which return `stream-error::last-operation-failed`
/// have a payload with more information about the operation that failed.
/// This payload can be passed through to this function to see if there's
/// filesystem-related information about the error to return.
///
/// Note that this function is fallible because not all stream-related
/// errors are filesystem-related errors.
pub fn filesystem_error_code(err : @error.Error_) -> ErrorCode? {
  let return_area = @ffi.malloc(2)
  wasmImportFilesystemErrorCode(err._, return_area)
  let lifted : ErrorCode? = match @ffi.load8_u(return_area + 0) {
    0 => Option::None
    1 => Option::Some(ErrorCode::from(@ffi.load8_u(return_area + 1)))
    _ => panic()
  }
  @ffi.free(return_area)
  return lifted
}
