// Generated by `wit-bindgen` 0.29.0. DO NOT EDIT!
/// Errors related to interacting with Redis
pub enum Error_ {
  InvalidAddress
  TooManyConnections
  TypeError
  Other(String)
} derive(Show, Eq)

pub type Connection Int derive(Show, Eq)

fn wasmImportResourceDropConnection(resource : Int) = "gmlewis:spin-moonbit-sdk/redis" "[resource-drop]connection"

pub fn Connection::drop(self : Connection) -> Unit {
  wasmImportResourceDropConnection(self.0)
}

/// A parameter type for the general-purpose `execute` function.
pub enum RedisParameter {
  Int64(Int64)
  Binary(Bytes)
} derive(Show, Eq)

/// A return type for the general-purpose `execute` function.
pub enum RedisResult {
  Nil
  Status(String)
  Int64(Int64)
  Binary(Bytes)
} derive(Show, Eq)

/// Open a connection to the Redis instance at `address`.
pub fn Connection::open(address : String) -> Result[Connection, Error_] {
  let return_area = @ffi.malloc(16)
  wasmImportStaticConnectionOpen(
    @ffi.str2ptr(address),
    address.iter().count(),
    return_area,
  )
  let lifted10 = match @ffi.load8_u(return_area + 0) {
    0 => Result::Ok(Connection::Connection(@ffi.load32(return_area + 4)))
    1 => {
      let lifted = match @ffi.load8_u(return_area + 4) {
        0 => Error_::InvalidAddress
        1 => Error_::TooManyConnections
        2 => Error_::TypeError
        3 => {
          let result = @ffi.ptr2str(@ffi.load32(return_area + 8))
          Error_::Other(result)
        }
        _ => panic()
      }
      Result::Err(lifted)
    }
    _ => panic()
  }
  ignore(address)
  @ffi.free(return_area)
  return lifted10
}

/// Publish a Redis message to the specified channel.
pub fn Connection::publish(
  self : Connection,
  channel : String,
  payload : Bytes
) -> Result[Unit, Error_] {
  let return_area = @ffi.malloc(16)
  wasmImportMethodConnectionPublish(
    self.0,
    @ffi.str2ptr(channel),
    channel.iter().count(),
    @ffi.bytes2ptr(payload),
    payload.length(),
    return_area,
  )
  let lifted10 = match @ffi.load8_u(return_area + 0) {
    0 => Result::Ok(())
    1 => {
      let lifted = match @ffi.load8_u(return_area + 4) {
        0 => Error_::InvalidAddress
        1 => Error_::TooManyConnections
        2 => Error_::TypeError
        3 => {
          let result = @ffi.ptr2str(@ffi.load32(return_area + 8))
          Error_::Other(result)
        }
        _ => panic()
      }
      Result::Err(lifted)
    }
    _ => panic()
  }
  ignore(channel)
  ignore(payload)
  @ffi.free(return_area)
  return lifted10
}

/// Get the value of a key.
pub fn Connection::get(
  self : Connection,
  key : String
) -> Result[Bytes?, Error_] {
  let return_area = @ffi.malloc(16)
  wasmImportMethodConnectionGet(
    self.0,
    @ffi.str2ptr(key),
    key.iter().count(),
    return_area,
  )
  let lifted16 = match @ffi.load8_u(return_area + 0) {
    0 => {
      let lifted : Bytes? = match @ffi.load8_u(return_area + 4) {
        0 => Option::None
        1 => {
          let result = @ffi.ptr2bytes(@ffi.load32(return_area + 8))
          Option::Some(result)
        }
        _ => panic()
      }
      Result::Ok(lifted)
    }
    1 => {
      let lifted15 = match @ffi.load8_u(return_area + 4) {
        0 => Error_::InvalidAddress
        1 => Error_::TooManyConnections
        2 => Error_::TypeError
        3 => {
          let result14 = @ffi.ptr2str(@ffi.load32(return_area + 8))
          Error_::Other(result14)
        }
        _ => panic()
      }
      Result::Err(lifted15)
    }
    _ => panic()
  }
  ignore(key)
  @ffi.free(return_area)
  return lifted16
}

/// Set key to value.
///
/// If key already holds a value, it is overwritten.
pub fn Connection::set(
  self : Connection,
  key : String,
  value : Bytes
) -> Result[Unit, Error_] {
  let return_area = @ffi.malloc(16)
  wasmImportMethodConnectionSet(
    self.0,
    @ffi.str2ptr(key),
    key.iter().count(),
    @ffi.bytes2ptr(value),
    value.length(),
    return_area,
  )
  let lifted10 = match @ffi.load8_u(return_area + 0) {
    0 => Result::Ok(())
    1 => {
      let lifted = match @ffi.load8_u(return_area + 4) {
        0 => Error_::InvalidAddress
        1 => Error_::TooManyConnections
        2 => Error_::TypeError
        3 => {
          let result = @ffi.ptr2str(@ffi.load32(return_area + 8))
          Error_::Other(result)
        }
        _ => panic()
      }
      Result::Err(lifted)
    }
    _ => panic()
  }
  ignore(key)
  ignore(value)
  @ffi.free(return_area)
  return lifted10
}

/// Increments the number stored at key by one.
///
/// If the key does not exist, it is set to 0 before performing the operation.
/// An `error::type-error` is returned if the key contains a value of the wrong type
/// or contains a string that can not be represented as integer.
pub fn Connection::incr(
  self : Connection,
  key : String
) -> Result[Int64, Error_] {
  let return_area = @ffi.malloc(24)
  wasmImportMethodConnectionIncr(
    self.0,
    @ffi.str2ptr(key),
    key.iter().count(),
    return_area,
  )
  let lifted10 = match @ffi.load8_u(return_area + 0) {
    0 => Result::Ok(@ffi.load64(return_area + 8))
    1 => {
      let lifted = match @ffi.load8_u(return_area + 8) {
        0 => Error_::InvalidAddress
        1 => Error_::TooManyConnections
        2 => Error_::TypeError
        3 => {
          let result = @ffi.ptr2str(@ffi.load32(return_area + 12))
          Error_::Other(result)
        }
        _ => panic()
      }
      Result::Err(lifted)
    }
    _ => panic()
  }
  ignore(key)
  @ffi.free(return_area)
  return lifted10
}

/// Removes the specified keys.
///
/// A key is ignored if it does not exist. Returns the number of keys deleted.
pub fn Connection::del(
  self : Connection,
  keys : Array[String]
) -> Result[UInt, Error_] {
  let cleanupList : Array[@ffi.Cleanup] = []
  let ignoreList : Array[@ffi.Any] = []
  let address = @ffi.malloc(keys.length() * 8)
  for index = 0; index < keys.length(); index = index + 1 {
    let element : String = keys[index]
    let base = address + index * 8
    @ffi.store32(base + 4, element.iter().count())
    @ffi.store32(base + 0, @ffi.str2ptr(element))
    ignoreList.push(element)
  }
  let return_area = @ffi.malloc(16)
  wasmImportMethodConnectionDel(self.0, address, keys.length(), return_area)
  let lifted12 = match @ffi.load8_u(return_area + 0) {
    0 => Result::Ok(@ffi.load32(return_area + 4).to_uint())
    1 => {
      let lifted = match @ffi.load8_u(return_area + 4) {
        0 => Error_::InvalidAddress
        1 => Error_::TooManyConnections
        2 => Error_::TypeError
        3 => {
          let result = @ffi.ptr2str(@ffi.load32(return_area + 8))
          Error_::Other(result)
        }
        _ => panic()
      }
      Result::Err(lifted)
    }
    _ => panic()
  }
  @ffi.free(address)
  @ffi.free(return_area)
  cleanupList.each(fn(cleanup) { @ffi.free(cleanup.address) })
  ignore(ignoreList)
  return lifted12
}

/// Add the specified `values` to the set named `key`, returning the number of newly-added values.
pub fn Connection::sadd(
  self : Connection,
  key : String,
  values : Array[String]
) -> Result[UInt, Error_] {
  let cleanupList : Array[@ffi.Cleanup] = []
  let ignoreList : Array[@ffi.Any] = []
  let address = @ffi.malloc(values.length() * 8)
  for index = 0; index < values.length(); index = index + 1 {
    let element : String = values[index]
    let base = address + index * 8
    @ffi.store32(base + 4, element.iter().count())
    @ffi.store32(base + 0, @ffi.str2ptr(element))
    ignoreList.push(element)
  }
  let return_area = @ffi.malloc(16)
  wasmImportMethodConnectionSadd(
    self.0,
    @ffi.str2ptr(key),
    key.iter().count(),
    address,
    values.length(),
    return_area,
  )
  let lifted12 = match @ffi.load8_u(return_area + 0) {
    0 => Result::Ok(@ffi.load32(return_area + 4).to_uint())
    1 => {
      let lifted = match @ffi.load8_u(return_area + 4) {
        0 => Error_::InvalidAddress
        1 => Error_::TooManyConnections
        2 => Error_::TypeError
        3 => {
          let result = @ffi.ptr2str(@ffi.load32(return_area + 8))
          Error_::Other(result)
        }
        _ => panic()
      }
      Result::Err(lifted)
    }
    _ => panic()
  }
  ignore(key)
  @ffi.free(address)
  @ffi.free(return_area)
  cleanupList.each(fn(cleanup) { @ffi.free(cleanup.address) })
  ignore(ignoreList)
  return lifted12
}

/// Retrieve the contents of the set named `key`.
pub fn Connection::smembers(
  self : Connection,
  key : String
) -> Result[Array[String], Error_] {
  let return_area = @ffi.malloc(16)
  wasmImportMethodConnectionSmembers(
    self.0,
    @ffi.str2ptr(key),
    key.iter().count(),
    return_area,
  )
  let lifted13 = match @ffi.load8_u(return_area + 0) {
    0 => {
      let array : Array[String] = []
      for index = 0; index < @ffi.load32(return_area + 8); index = index + 1 {
        let base1 = @ffi.load32(return_area + 4) + index * 8
        let result = @ffi.ptr2str(@ffi.load32(base1 + 0))
        array.push(result)
      }
      @ffi.free(@ffi.load32(return_area + 4))
      Result::Ok(array)
    }
    1 => {
      let lifted = match @ffi.load8_u(return_area + 4) {
        0 => Error_::InvalidAddress
        1 => Error_::TooManyConnections
        2 => Error_::TypeError
        3 => {
          let result12 = @ffi.ptr2str(@ffi.load32(return_area + 8))
          Error_::Other(result12)
        }
        _ => panic()
      }
      Result::Err(lifted)
    }
    _ => panic()
  }
  ignore(key)
  @ffi.free(return_area)
  return lifted13
}

/// Remove the specified `values` from the set named `key`, returning the number of newly-removed values.
pub fn Connection::srem(
  self : Connection,
  key : String,
  values : Array[String]
) -> Result[UInt, Error_] {
  let cleanupList : Array[@ffi.Cleanup] = []
  let ignoreList : Array[@ffi.Any] = []
  let address = @ffi.malloc(values.length() * 8)
  for index = 0; index < values.length(); index = index + 1 {
    let element : String = values[index]
    let base = address + index * 8
    @ffi.store32(base + 4, element.iter().count())
    @ffi.store32(base + 0, @ffi.str2ptr(element))
    ignoreList.push(element)
  }
  let return_area = @ffi.malloc(16)
  wasmImportMethodConnectionSrem(
    self.0,
    @ffi.str2ptr(key),
    key.iter().count(),
    address,
    values.length(),
    return_area,
  )
  let lifted12 = match @ffi.load8_u(return_area + 0) {
    0 => Result::Ok(@ffi.load32(return_area + 4).to_uint())
    1 => {
      let lifted = match @ffi.load8_u(return_area + 4) {
        0 => Error_::InvalidAddress
        1 => Error_::TooManyConnections
        2 => Error_::TypeError
        3 => {
          let result = @ffi.ptr2str(@ffi.load32(return_area + 8))
          Error_::Other(result)
        }
        _ => panic()
      }
      Result::Err(lifted)
    }
    _ => panic()
  }
  ignore(key)
  @ffi.free(address)
  @ffi.free(return_area)
  cleanupList.each(fn(cleanup) { @ffi.free(cleanup.address) })
  ignore(ignoreList)
  return lifted12
}

/// Execute an arbitrary Redis command and receive the result.
pub fn Connection::execute(
  self : Connection,
  command : String,
  arguments : Array[RedisParameter]
) -> Result[Array[RedisResult], Error_] {
  let cleanupList : Array[@ffi.Cleanup] = []
  let ignoreList : Array[@ffi.Any] = []
  let address = @ffi.malloc(arguments.length() * 16)
  for index = 0; index < arguments.length(); index = index + 1 {
    let element : RedisParameter = arguments[index]
    let base = address + index * 16
    match element {
      Int64(payload) => {
        @ffi.store8(base + 0, 0)
        @ffi.store64(base + 8, payload)
        ()
      }
      Binary(payload4) => {
        @ffi.store8(base + 0, 1)
        @ffi.store32(base + 12, payload4.length())
        @ffi.store32(base + 8, @ffi.bytes2ptr(payload4))
        ignoreList.push(payload4)
        ()
      }
      _ => panic()
    }
  }
  let return_area = @ffi.malloc(16)
  wasmImportMethodConnectionExecute(
    self.0,
    @ffi.str2ptr(command),
    command.iter().count(),
    address,
    arguments.length(),
    return_area,
  )
  let lifted31 = match @ffi.load8_u(return_area + 0) {
    0 => {
      let array : Array[RedisResult] = []
      for index18 = 0
          index18 < @ffi.load32(return_area + 8)
          index18 = index18 + 1 {
        let base8 = @ffi.load32(return_area + 4) + index18 * 16
        let lifted = match @ffi.load8_u(base8 + 0) {
          0 => RedisResult::Nil
          1 => {
            let result = @ffi.ptr2str(@ffi.load32(base8 + 8))
            RedisResult::Status(result)
          }
          2 => RedisResult::Int64(@ffi.load64(base8 + 8))
          3 => {
            let result17 = @ffi.ptr2bytes(@ffi.load32(base8 + 8))
            RedisResult::Binary(result17)
          }
          _ => panic()
        }
        array.push(lifted)
      }
      @ffi.free(@ffi.load32(return_area + 4))
      Result::Ok(array)
    }
    1 => {
      let lifted30 = match @ffi.load8_u(return_area + 4) {
        0 => Error_::InvalidAddress
        1 => Error_::TooManyConnections
        2 => Error_::TypeError
        3 => {
          let result29 = @ffi.ptr2str(@ffi.load32(return_area + 8))
          Error_::Other(result29)
        }
        _ => panic()
      }
      Result::Err(lifted30)
    }
    _ => panic()
  }
  ignore(command)
  @ffi.free(address)
  @ffi.free(return_area)
  cleanupList.each(fn(cleanup) { @ffi.free(cleanup.address) })
  ignore(ignoreList)
  return lifted31
}
